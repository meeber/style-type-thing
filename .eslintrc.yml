parserOptions:
  ecmaVersion: 2017
env:
  es6: true
rules:
  ###################
  # Possible Errors #
  ###################

  # Don't put an assignment expression inside of a conditional unless necessary
  # for a reason other than elegance, in which case express intent by disabling
  # this rule via an inline comment. Otherwise, it reduces correctness, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # type `=` instead of `===`?
  #
  # The `always` option is set instead of the default `except-parens` option
  # because wrapping the assignment in an extra set of parenthesis isn't
  # sufficient for expressing intent.
  no-cond-assign:
    - error
    - always

  # Don't release code containing a `console` statement unless in a development
  # environment, in which case set this rule to `warn` instead of `error` in the
  # local config file so that the build doesn't fail but reminders are still
  # provided. Otherwise, it reduces security by leaking debugging information to
  # users.
  no-console: error

  # Don't use a constant expression as a conditional unless necessary for a
  # reason other than elegance, in which case express intent by disabling this
  # rule via an inline comment, or assign the constant to a variable with an
  # explanatory name. Otherwise, it reduces correctness, and reduces
  # expressiveness by creating doubt: did the developer accidentally create an
  # infinite loop?
  no-constant-condition:
    - error
    - checkLoops: true

  # When using control characters in regular expressions, always express intent
  # by disabling this rule via an inline comment; it improves expressiveness by
  # removing doubt: did the developer accidentally type a control character? If
  # use of control characters is expected in a project, then disable this rule
  # in the local config file.
  no-control-regex: error

  # Don't release code containing a `debugger` statement unless in a development
  # environment, in which case set this rule to `warn` instead of `error` in the
  # local config file so that the build doesn't fail but reminders are still
  # provided. Otherwise, it reduces security by leaking debugging information to
  # users.
  no-debugger: error

  # Never define a function that has multiple arguments with the same name; it's
  # pointless because the last occurrence shadows the one(s) before it. This
  # problem usually happens on accident.
  no-dupe-args: error

  # Never define an object literal that has multiple properties with the same
  # name; it's pointless because the last occurrence shadows the one(s) before
  # it. This problem usually happens on accident.
  no-dupe-keys: error

  # Never define a `switch` statement that has multiple cases with the same
  # clause; it's pointless because the first occurrence is the only one that'll
  # ever be matched. This problem usually happens on accident.
  no-duplicate-case: error

  # When writing an empty code block, always express intent by adding a comment
  # inside; it improves expressiveness by removing doubt: did the developer
  # accidentally leave behind an empty block after refactoring?
  no-empty:
    - error
    - allowEmptyCatch: false

  # Never include empty brackets in a regular expression; it's pointless because
  # an empty character set doesn't match anything. If needing to include "[]" as
  # part of the pattern, then escape each bracket. This problem usually happens
  # on accident.
  no-empty-character-class: error

  # Never reassign the exception parameter in a `catch` block; it reduces
  # correctness and debuggability, and reduces consistency by defying the
  # expectation that the exception parameter will always reference the caught
  # error. Instead, assign the exception to a separate variable that can later
  # be reassigned as necessary.
  no-ex-assign: error

  # Never cast a variable to a boolean as part of a test condition; it's
  # pointless because it's done automatically by the engine. This problem
  # usually happens as a misguided attempt to add expressiveness where none is
  # needed.
  no-extra-boolean-cast: error

  # When combining binary expressions of varying precedence, always add extra
  # parentheses; it increases correctness, and increases expressiveness by
  # removing doubt: did the developer fully understand order of operations?
  # Never add extra parentheses in other situations; it reduces elegance as part
  # of a misguided attempt to add expressiveness where none is needed.
  #
  # Note that the `no-mixed-operators` rule enforces the use of extra
  # parentheses when combining binary expressions of varying precedence. This
  # rule merely gets out of the way of the `no-mixed-operators` rule while also
  # preventing extra parentheses in other situations.
  no-extra-parens:
    - error
    - all
    - conditionalAssign: false
      nestedBinaryExpressions: true
      returnAssign: false

  # Never put semicolons anywhere that not even automatic semicolon insertion
  # would add one; it's pointless. This problem usually happens on accident by
  # typing `;;` instead of `;`, or by adding a `;` after the closing brace of a
  # function declaration.
  no-extra-semi: error

  # Never reassign a function declaration; it reduces correctness and
  # debugabbility, and reduces consistency by defying the expectation that a
  # function defined in this manner will never be reassigned. Instead, assign a
  # function expression to a variable that can later be reassigned as necessary.
  #
  # Note that the `func-style` rule enforces the use of function expressions
  # over function declarations and arrow functions.
  no-func-assign: error

  # Feel free to use function declarations in nested blocks; starting with ES6,
  # function declarations are appropriately block-scoped. Better yet, use a
  # function expression; it improves consistency.
  # 
  # This rule is disabled because it only applies to pre-ES5 environments. Note
  # that the `func-style` rule enforces the use of function expressions over
  # function declarations and arrow functions. Also, the `no-var` rule enforces
  # the use of  `let` and `const` over `var`.
  no-inner-declarations: off

  # Never put an invalid regular expression inside of a `RegExp` constructor; it
  # throws a `SyntaxError` when executed. This problem usually happens on
  # accident.
  no-invalid-regexp: error

  # Don't use non-standard whitespace characters unless necessary for a reason
  # other than elegance, in which case express intent by disabling this rule via
  # an inline comment. Otherwise, it reduces correctness and debuggability, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # copy and paste code from the web that contained non-standard whitespace
  # characters?
  no-irregular-whitespace:
    - error
    - skipStrings: false
      skipComments: false
      skipRegExps: false
      skipTemplates: false

  # Never invoke non-function global objects such as `Math` or `JSON` as if
  # they're functions; it throws a `TypeError` when executed. This problem
  # usually happens on accident.
  no-obj-calls: error

  # Never directly invoke an `Object.prototype` method on an object; it's
  # possible for such methods to be shadowed, or for an object to not even have
  # `Object.prototype` in its prototype chain, thus reducing correctness.
  # Instead, use `call`, or wrap them in stand-alone helper functions.
  no-prototype-builtins: error

  # Never chain multiple spaces together in a regex; it reduces correctness, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # type `  ` instead of ` `? Instead, use a single space followed by `{n}`
  # where `n` is the number of spaces.
  no-regex-spaces: error

  # Don't create a sparse array unless necessary for a reason other than
  # elegance or performance, in which case express intent by disabling this rule
  # via an inline comment. Otherwise, it reduces correctness, and reduces
  # accessibility because it's not widely understood how sparse arrays work, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # type `,,` instead of `,`?
  no-sparse-arrays: error

  # Don't put a template literal placeholder such as `${var}` inside of a
  # single- or double-quoted string unless necessary for a reason other than
  # elegance, in which case express intent by disabling this rule via an inline
  # comment. Otherwise, it reduces correctness, and reduces expressiveness by
  # creating doubt: did the developer accidentally use single or double quotes
  # instead of backticks?
  no-template-curly-in-string: error

  # Never split an expression across multiple lines in such a way that the
  # newline looks like it's ending the statement when it's not; it reduces
  # correctness and elegance without adding value.
  no-unexpected-multiline: error

  # Never put code after an unconditional exit statement; it's pointless because
  # it's never executed. This problem usually happens on accident.
  no-unreachable: error

  # Never put a control flow statement such as `return` inside of a `finally`
  # block; it reduces correctness, and reduces accessibility because it's not
  # widely understood that control flow statements inside of a `finally` block
  # take priority over control flow statement inside of a `try` or `catch`
  # block.
  no-unsafe-finally: error

  # Never negate the left operand when using `in` or `instanceof`; it reduces
  # correctness, and reduces expressiveness by creating doubt: did the developer
  # accidentally negate the operand instead of the full expression by forgetting
  # to wrap the full expression in parentheses?
  no-unsafe-negation: error

  # Never compare a value to `NaN`; it reduces correctness, and reduces
  # accessibility because it's not widely understood that `NaN` is the only
  # value in JavaScript that's not equal to itself. Instead, use `isNaN` or
  # `Number.isNaN`.
  use-isnan: error

  # This rule is disabled due to lack of jsdoc usage. It may be enabled in the
  # future.
  valid-jsdoc: off

  # Never compare a `typeof` expression to any string literal other than one of
  # the valid types; it's pointless because it always fails.
  #
  # The `requireStringLiterals` option is set to `false` because comparing a
  # `typeof` expression to a variable is a normal thing to do, and it doesn't
  # inherently reduce correctness.
  valid-typeof:
    - error
    - requireStringLiterals: false

  ##################
  # Best Practices #
  ##################

  # Never define a setter via `set` without a corresponding getter, or
  # vice-versa; it reduces testability because it often leads to unverifiable
  # results, and reduces consistency by defying the expectation that a property
  # that can be assigned a value via an assignment operator can also have the
  # value retrieved via simple property access, and vice-versa.
  accessor-pairs:
    - error
    - setWithoutGet: true
      getWithoutSet: true
  
  # Never invoke one of Array's map/reduce methods without returning a value in
  # the callback; it reduces correctness, and reduces expressiveness by creating
  # doubt: did the developer forget to return a value? If the method was just
  # being used to invoke a function for each entry in an array, then use
  # `Array.prototype.forEach` instead.
  array-callback-return: error

  # Never use a variable defined via `var` outside of the block in which it was
  # defined; it reduces correctness, and reduces accessibility because variable
  # hoisting isn't widely understood. Instead, move the definition to the top of
  # the variable scope. Or better yet, use `let` or `const` instead; they're
  # both block-scoped.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  block-scoped-var: error

  # Never define a class method that doesn't reference `this`; it reduces
  # correctness, and reduces expressiveness by creating doubt: did the developer
  # accidentally reference a local variable instead of an instance property?
  # Instead, use a static class function. Better yet, don't use classes or
  # `this` at all; they reduce correctness, expressiveness, and accessibility
  # due to the ambiguity of `this`. 
  class-methods-use-this: error

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  complexity: off

  # Never define a function that returns a value in one code path but not
  # another; it reduces correctness, and reduces expressiveness by creating
  # doubt: did the developer forget to return a value in a code path? If one
  # code path needs to return a value, but another doesn't, then express intent
  # by having the latter return `null` instead of `undefined`. Otherwise, it
  # reduces correctness, debuggability, expressiveness, and accessibility due to
  # the ambiguity of `undefined` (which can mean either "undeclared", "declared
  # but unassigned", or "declared and explicitly assigned to `undefined`").
  consistent-return:
    - error
    - treatUndefinedAsUnspecified: false

  # Put braces around conditional execution blocks unless every execution block
  # in a grouping fits on the same line as its condition; it improves elegance.
  curly:
    - error
    - multi-line
    - consistent

  # Always add a `// no default` comment at the bottom of `switch` blocks that
  # don't have a `default` case; it improves correctness, and improves
  # expressiveness by removing doubt: did the developer forget to add a
  # `default` case?
  default-case: error

  # Always place the dot at the beginning of the property (instead of at the end
  # of the object) in multiline member expressions; it improves consistency, and
  # improves expressiveness by avoiding confusion caused by the role of periods
  # in the English language to indicate the end of a sentence.
  dot-location:
    - error
    - property

  # When accessing object properties, only use bracket notation when necessary,
  # such as when the key is a `Symbol` or variable. Otherwise, use dot notation;
  # it improves elegance.
  #
  # The `allowKeywords` option is set to `true` because maintaining ES3
  # compatibility usually isn't a requirement. If it's a requirement, then set
  # `allowKeywords` to `false` in the local config file.
  dot-notation:
    - error
    - allowKeywords: true

  # Always use `===` instead of `==`; it improves correctness and consistency,
  # and improves accessibility because implicit coercions via `==` aren't
  # widely understood, and improves expressiveness by removing doubt: did the
  # developer accidentally type `==` instead of `===`?
  eqeqeq:
    - error
    - always
    - null: always

  # When looping through keys via `for`/`in`, filter out inherited properties
  # via `Object.prototype.hasOwnProperty` unless inherited properties are
  # necessary, in which case express intent by disabling this rule via an
  # inline comment. Otherwise, it reduces correctness, and reduces accessibility
  # because it's not widely understood that `for`/`in` includes inherited
  # properties, and reduces expressiveness by creating doubt: did the developer
  # mean to include inherited properties?
  guard-for-in: error

  # Never use `alert`, `prompt`, or `confirm`; they create a poor user
  # experience. Instead, use a custom UI widget.
  no-alert: error

  # Never use `arguments.caller` or `arguments.callee`; they're deprecated.
  # Instead of using `arguments.caller`, the called function should accept the
  # calling function as a parameter. Instead of using `arguments.callee`, the
  # function should just reference itself by name.
  no-caller: error

  # Always put braces around a `case`'s execution block when it contains a
  # lexical declaration. Otherwise, it reduces correctness, and reduces
  # accessibility because it's not widely understood that the variable will be
  # scoped to the entire `switch` block instead of only the `case`'s execution
  # block.
  no-case-declarations: error

  # Don't bother escaping an equal sign at the start of a regex literal; it's
  # pointless, and the rest of the line provides sufficient context to avoid
  # ambiguity with a division operator.
  #
  # This rule is disabled because it's a misguided attempt at improving
  # correctness and expressiveness at the cost of elegance; no improvement is
  # needed.
  no-div-regex: off

  # Don't define an `else` block if the `if` block always returns when executed;
  # it's pointless because the `else` block always executes if the `if` block
  # doesn't. Instead, put the code outside, directly after the end of the
  # `if` block.
  no-else-return: error

  # When defining an empty function, always express intent by adding a comment
  # inside of the function body; it improves correctness, and improves
  # expressiveness by removing doubt: did the developer accidentally leave
  # behind an empty function after refactoring?
  #
  # It'd be nice if there was an option in ESLint to allow a function named
  # "noop" to be empty without needing a comment, since the name expresses
  # intent.
  no-empty-function: error

  # Never define an empty pattern (e.g., `let {a: {}} = obj`) when
  # destructuring; it's pointless because no properties are ever assigned. If
  # setting the default value of a property to an empty object, then type `=`
  # instead of `:` (e.g., `let {a = {}} = obj`). This problem usually happens on
  # accident.
  no-empty-pattern: error

  # When comparing a value against `null`, always use `===` instead of `==`.
  # Otherwise, it reduces correctness, and reduces accessibility because it's
  # not widely understood that `true` will be returned if the value is either
  # `null` or `undefined`, and reduces expressiveness by creating doubt: did the
  # developer accidentally type `==` instead of `===`? If testing for both
  # `null` or `undefined`, then express intent by performing two separate
  # comparisons using `===`.
  #
  # Note that the `eqeqeq` rule enforces the use of `===` over `==`. This rule
  # is only enabled in case the `eqeqeq` rule is disabled.
  no-eq-null: error

  # Never use `eval`; it reduces security by opening the door for injection
  # attacks, and reduces performance.
  no-eval:
    - error
    - allowIndirect: false

  # Never modify native objects such as `Object`; it reduces correctness, and
  # reduces consistency by defying the expectation that native objects always
  # behave a certain way.
  no-extend-native: error

  # Never create a new function with `bind` if the new function doesn't use
  # `this` or perform argument binding, or if the target function is an arrow
  # function; it's pointless because it adds no functionality over the unbound
  # version.
  no-extra-bind: error

  # Only use a label in a loop or switch if it's nested, and only if it's
  # necessary for a reason other than elegance; otherwise, it reduces
  # consistency because it defies the expectation of how labels should be used,
  # and reduces accessibility because labels aren't widely used.
  #
  # Note that the `no-labels` rule disallows the use of labels except in loops.
  no-extra-label: error

  # Never use fall-through logic in a `switch` block unless necessary for a
  # reason other than elegance, in which case express intent by adding a
  # `// fall through` comment at the end of the `case` block. Otherwise, it
  # reduces correctness, and reduces expressiveness by creating doubt: did the
  # developer forget to add a `break` statement at the end of a `case` block?
  no-fallthrough: error

  # Never leave either side of the decimal point blank in a decimal number; it
  # reduces expressiveness and consistency. Instead, add a zero (e.g., `0.3`
  # instead of `.3`, and `3.0` instead of `3.`).
  no-floating-decimal: error

  # Never reassign built-in global variables; it reduces correctness and
  # debuggability, and reduces consistency by defying the expectation that
  # built-in global variables always behave the same way.
  no-global-assign: error

  # Always perform coercions explicitly (e.g., `Boolean(val)`) instead of
  # implicitly (e.g., `!!val`); it improves correctness, and improves
  # accessibility because operators such as `~` aren't widely understood, and
  # improves expressiveness by removing doubt: did the developer accidentally
  # type `!!` instead of `!`?
  no-implicit-coercion:
    - error
    - boolean: true
      number: true
      string: true

  # Only declare a `var` or function declaration in the global scope when
  # necessary for a reason other than elegance, in which case express intent by
  # explicitly assigning it to the global object (e.g., `window` in the browser,
  # or `global` in Node.js`). Otherwise, it reduces correctness, and reduces
  # accessibility because it's not widely understood that top-level `var` and
  # function declarations are added as properties to the global object, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # create a global variable instead of a local one?
  #
  # Note that the `func-style` enforces the use of function expressions over
  # function declarations and arrow functions. Also, the `no-var` rule enforces
  # the use of `let` and `const` over `var`.
  no-implicit-globals: error

  # Never indirectly invoke `eval`-like behavior, such as by passing code as the
  # first argument to `setTimeout`; it reduces security by opening the door for
  # injection attacks, and reduces performance.
  no-implied-eval: error

  # Don't use `this` outside of expected blocks, such as constructors and object
  # methods, unless necessary for a reason other than elegance, in which case
  # disable this rule via an inline comment. It reduces correctness and
  # expressiveness, and reduces consistency because it defies the expectation of
  # how `this` is normally used. Better yet, don't use classes or `this` at all;
  # they reduce correctness, expressiveness, and accessibility due to the
  # ambiguity of `this`. 
  no-invalid-this: error

  # Never use the __iterator__ property; it's deprecated. Instead, use ES6
  # ES6 iterators and generators.
  no-iterator: error

  # Only use labels in conjunction with nested loops, and only when necessary.
  # Otherwise, it reduces consistency because it defies the expectation of how
  # labels should be used, and reduces accessibility because labels aren't
  # widely used.
  #
  # Note that the `no-extra-label` rule disallows the use of labels in
  # non-nested loops.
  no-labels:
    - error
    - allowLoop: true
      allowSwitch: false

  # Don't create standalone code blocks unless necessary for a reason other than
  # elegance, in which case express intent by disabling this rule via an inline
  # comment. Otherwise, it reduces expressiveness by creating doubt: did the
  # developer accidentally leave behind a standalone code block after
  # refactoring? There's rarely a compelling reason to create a standalone code
  # block on purpose.
  no-lone-blocks: error

  # Don't define functions inside of loops unless necessary for a reason other
  # than elegance, in which case disable this rule via an inline comment.
  # Otherwise, it reduces correctness, and reduces accessibility because it's
  # not widely understood that all instances of an inner function will reference
  # the same outer incremental variable declared via `var`.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`.
  no-loop-func: error

  # Only use numbers explicitly when accessing array elements. In other
  # situations, assign numbers to descriptively named constants or properties.
  # Otherwise, it reduces expressivess and accessibility because it's not always
  # obvious what the numbers represent. If this rule proves too onerous, then
  # disable it in the local config file.
  #
  # It'd be nice if the `ignoreArrayIndexes` option also applied to `indexOf`.
  no-magic-numbers:
    - error
    - detectObjects: false
      enforceConst: true
      ignoreArrayIndexes: true

  # Don't chain multiple spaces together for purposes other than indentation; it
  # reduces maintainability, especially when adding spaces to align object
  # property values across multiple lines. Whenever a new property is added to
  # the object with a longer name than the existing properties, all properties
  # in the object must be realigned, resulting in noisy diffs. Although it
  # improves elegance, it's not worth the cost.
  #
  # Note that the `key-spacing` rule also prevents multiple spaces from being
  # added after the colon in object property values. This rule prevents multiple
  # spaces everywhere.
  no-multi-spaces:
    - error
    - exceptions:
        Property: false

  # Never create multiline strings by putting `\` at the end of each line.
  # Instead, use string concatenation or template literals; it improves
  # elegance.
  no-multi-str: error

  # Never create functions using `new Function()`; it reduces security by
  # opening the door for injection attacks, and reduces performance.
  no-new-func: error

  # Never create primitives via `new String`, `new Number`, or `new Boolean`; it
  # reduces correctness, and reduces accessibility because it's not widely
  # understood that they're considered objects, causing `typeof` to return
  # "object", and `new Boolean(false)` to resolve to `true`.
  no-new-wrappers: error

  # When using `new` but not assigning the result to a variable, always express
  # intent by disabling this rule via an inline comment. Otherwise, it reduces
  # consistency because it defies the expectation of how `new` is normally used,
  # and reduces expressiveness by creating doubt: did the developer forget to
  # assign the result to a variable?
  no-new: error

  # Never use octal escape sequences in string literals; they're deprecated in
  # ES5. Instead, use unicode escape sequences.
  no-octal-escape: error

  # Never use octal literals (e.g., `071`); they're deprecated in ES5.
  no-octal: error

  # Never reassign a function argument; it reduces correctness and
  # debuggability, and reduces consistency because it defies the expectation
  # that an argument always references the variable that was passed in when the
  # function was invoked. Instead, assign the argument to a local variable that
  # can later be reassigned as necessary.
  #
  # The `props` option is set to `false` because although it improves
  # correctness to treat all arguments as immutable, doing so significantly
  # reduces accessibility, elegance, and performance due to the difficulty and
  # implications of practicing a purely functional programming style. If the
  # costs are considered worth the benefit, then set the `props` option to
  # `true` in the local config file.
  no-param-reassign:
    - error
    - props: false

  # Never use the `__proto__` property; it's deprecated in ES3.1. Instead, use
  # `Object.getPrototypeOf`.
  no-proto: error

  # Never redeclare a variable using `var`; it's pointless. Instead, just
  # reassign the previously declared variable. Even better, use `let` instead of
  # `var`. 
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  no-redeclare:
    - error
    - builtinGlobals: true

  # This rule is disabled. It may be enabled in the future if there are
  # properties that are deemed important enough to disallow by default.
  no-restricted-properties: off

  # Don't return an assignment expression unless necessary for a reason other
  # than elegance, in which case express intent by disabling this rule via an
  # inline comment. Otherwise, it reduces correctness, and reduces
  # expressiveness by creating doubt: did the developer accidentally type `=`
  # instead of `===`?
  #
  # The `always` option is used instead of the `except-parens` option because
  # adding parentheses doesn't sufficiently express intent.
  no-return-assign:
    - error
    - always

  # Never use `location.href = "javascript:<code>"`; it reduces security by
  # opening the door for injection attacks, and reduces performance.
  no-script-url: error

  # Never assign a variable or object property to itself; it's pointless. It's
  # common for this to be done on accident.
  no-self-assign:
    - error
    - props: true

  # Never compare a variable to itself; it reduces correctness, and reduces
  # accessibility because it's not widely understood that `NaN` is the only
  # value in JavaScript that doesn't equal itself, and reduces expressiveness by
  # creating doubt: did the developer accidentally compare a value to itself
  # instead of to another value? If testing for `NaN`, then use the global
  # `isNaN` or `Number.isNaN` functions instead.
  no-self-compare: error

  # Never use the comma operator unless defining the initialization or
  # final-expression portions of a `for` statement; it reduces correctness, and
  # reduces accessibility because it's not widely understood that the comma
  # operator executes each expression from left to right and returns the value
  # of the last operand.
  #
  # Note that this rule doesn't apply to using commas in argument lists.
  no-sequences: error

  # Never throw any value other than an `Error` object, or an object that
  # extends `Error`; it reduces debuggability due to the lack of a stack trace,
  # and reduces consistency because it defies the expectation of what properties
  # a thrown error includes.
  no-throw-literal: error

  # Don't create a loop with a condition that's not modified within the loop
  # unless necessary for a reason other than elegance, in which case express
  # intent by disabling this rule via an inline comment; it reduces correctness,
  # and reduces expressiveness by creating doubt: did the developer accidentally
  # create an infinite loop?
  no-unmodified-loop-condition: error

  # Never write an expression that doesn't have any effect; it's pointless. This
  # problem usually happens on accident due to a mistake in logic.
  no-unused-expressions:
    - error
    - allowShortCircuit: false
      allowTernary: false

  # Never define a label that's never used; it's pointless. This problem usually
  # happens on accident as a result of refactoring.
  no-unused-labels: error

  # Only use `.call` or `.apply` when necessary, such as when explicitly setting
  # `this`, or, in the case of `.apply`, when passing in arguments as an array.
  # Otherwise, it's pointless because it's the same as invoking the functions
  # normally, except it reduces elegance and performance. This problem usually
  # happens on accident as a result of refactoring.
  #
  # Note that the `prefer-spread` rule enforces the use of the spread operator
  # over using `.apply`.
  no-useless-call: error

  # Only use string concatenation when necessary, such as when breaking up a
  # long string across multiple lines. Otherwise, it's pointless because it's
  # the same as putting everything inside of a single string, except it reduces
  # elegance and performance. This problem usually happens on accident as a
  # result of refactoring.
  # 
  # Note that the `prefer-template` rule enforces the use of template literals
  # over string concatenation when embedding expressions. This rule addresses
  # situations that don't involve embedding expressions.
  no-useless-concat: error

  # Never escape non-special characters in strings, template literals, and
  # regular expressions; it's pointless. This problem usually happens on
  # accident due to escaping the wrong character.
  no-useless-escape: error

  # Never use the `void` operator; it reduces expressiveness and elegance, and
  # reduces accessibility because it's not widely understood that `void` always
  # returns `undefined`. Instead, reference `undefined` directly. Better yet,
  # use `null` instead of `undefined` whenever possible; it improves
  # correctness, debuggability, expressiveness, and accessibility due to the
  # ambiguity of `undefined` (which can mean either "undeclared", "declared but
  # unassigned", or "declared and explicitly assigned to `undefined`"). 
  #
  # Note that some guides recommend using `void` instead of referencing
  # `undefined` directly because `undefined` can be redefined or shadowed, thus
  # reducing correctness. But starting with ES5, the global `undefined` can't be
  # redefined, and the `no-shadow-restricted-names` rule disallows shadowing
  # `undefined`.
  no-void: error

  # Feel free to add inline reminders using `// TODO:` comments; it improves
  # maintainability, and is more effective than keeping a list of issues in a
  # separate document.
  #
  # This rule is set to `warn` so that it provides reminders about outstanding
  # issues but doesn't cause the build to fail.
  no-warning-comments: warn

  # Never use the `with` statement; it's disallowed in strict mode, and it
  # reduces correctness, expressiveness, and accessibility because it's a highly
  # error-prone and misunderstood feature.
  no-with: error

  # When using `parseInt`, always provide the radix; it improves correctness and
  # consistency, and improves expressiveness by removing doubt: did the
  # developer forget to provide the radix?
  #
  # This rule is still worth it even though in ES5 the `parseInt` function no
  # longer auto-detects octals, so the risk of accidentally ending up with the
  # wrong radix via auto-detection due to an errant leading zero is reduced.
  radix:
    - error
    - always

  # Always put `var` declarations at the top of the function or program; it
  # improves correctness, and improves accessibility because variable hoisting
  # isn't widely understood. Better yet, use `let` and `const` instead of `var`.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  vars-on-top: error

  # Always wrap immediately-invoked function expressions (even when invoked via
  # `.call` or `.apply`) in parentheses; it improves consistency and elegance.
  wrap-iife:
    - error
    - inside
    - functionPrototypeMethods: true

  # Never use the yoda style (e.g., `if (5 === x)`); it reduces consistency,
  # elegance, and accessibility because it acts contrary to the natural flow of
  # thought. Also, the `no-cond-assign` rule already protects against the
  # accidental assignment of variables in conditionals, overlapping any benefit
  # of the yoda style in terms of correctness.
  yoda:
    - error
    - never

  ###############
  # Strict Mode #
  ###############

  # Always enable strict mode at the global level; it improves correctness by
  # preventing common mistakes. In Node.js code, put `"use strict";` at the top
  # of each module file. Once ES6 modules are implemented, or when transpiling
  # via babel, disable this rule in the local config file; strict mode is either
  # implied or enabled automatically.
  strict:
    - error
    - global

  #############
  # Variables #
  #############

  # Always assign variables at the same time that they're declared; it improves
  # correctness, and improves expressiveness by removing doubt; did the
  # developer forget to assign an initial value? If declaring a variable before
  # its value has been determined, then assign it to `null` instead of
  # `undefined`; it improves correctness, debuggability, expressiveness, and
  # accessibility due to the ambiguity of `undefined` (which can mean either
  # "undeclared", "declared but unassigned", or "declared and explicitly
  # assigned to `undefined`").
  init-declarations:
    - error
    - always

  # This rule is disabled because it protects against a bug that's only present
  # in IE8 and earlier.
  no-catch-shadow: off

  # Never use `delete` on a variable; it only works on object properties. If
  # resetting a variable, then reassign it to `null`.
  #
  # Note that the `prefer-reflect` rule enforces the use of
  # `Reflect.deleteProperty` over `delete`. This rule is only enabled in case
  # the `prefer-reflect` rule is disabled.
  no-delete-var: error

  # Never declare a variable with the same name as a label, or vice-versa; it
  # reduces debuggability and expressiveness due to the resulting ambiguity.
  no-label-var: error

  # This rule is disabled. It may be enabled in the future if there are global
  # variables that are deemed important enough to disallow by default.
  no-restricted-globals: off

  # Never shadow a global object or identifier such as `undefined`; it reduces
  # correctness, and reduces consistency because it defies the expectation that
  # global objects and identifiers can be referenced anywhere by name.
  no-shadow-restricted-names: error

  # Never declare a variable in an inner scope with the same name as an existing
  # variable in an outer scope (including global variables); it reduces
  # correctness, and reduces expressiveness by creating doubt: did the developer
  # accidentally declare a variable with the same name instead of referencing
  # the existing one in the outer scope?
  #
  # The `hoist` option is set to `all` because although it's not technically
  # shadowing when the variable in the outer scope is declared after the inner
  # function, and thus the chance of closure-related mistakes is lowered, it
  # still reduces expressiveness without adding value.
  no-shadow:
    - error
    - builtinGlobals: true
      hoist: all
 
  # When initializing a variable to `undefined`, always do so explicitly instead
  # of implicitly; it improves correctness, and improves expressiveness by
  # removing doubt: did the developer forget to assign an initial value? Better
  # yet, initialize the variable to `null` instead of `undefined` whenever
  # possible; it improves correctness, debuggability, expressiveness, and
  # accessibility due to the ambiguity of `undefined` (which can mean either
  # "undeclared", "declared but unassigned", or "declared and explicitly
  # assigned to `undefined`").
  #
  # This rule is disabled because it promotes implicitly initializing a variable
  # to `undefined` instead of doing so explicitly. The argument in favor of
  # implicitness is that `undefined` can be redefined or shadowed, thus reducing
  # correctness. But starting with ES5, the global `undefined` can't be
  # redefined, and the `no-shadow-restricted-names` rule disallows shadowing
  # `undefined`.
  #
  # Note that the `init-declarations` rule disallows declaring a variable
  # without explicitly initializing it at the same time.
  no-undef-init: off

  # Never reference a variable that hasn't been declared, not even when using
  # the `typeof` operator; it reduces correctness, and reduces expressiveness
  # by creating doubt: did the developer mistype the variable name? If the
  # variable is a global that's not recognized by ESLint for the specified
  # environment, then add the variable to the `globals` section of the local
  # config file.
  no-undef:
    - error
    - typeof: true

  # When referencing `undefined`, always do so explicitly instead of implicitly;
  # it improves correctness and expressiveness, and improves accessibility
  # because it's not widely understood that `void` always returns `undefined`.
  # Better yet, use `null` instead of `undefined` whenever possible; it improves
  # correctness, debuggability, expressiveness, and accessibility due to the
  # ambiguity of `undefined` (which can mean either "undeclared", "declared but
  # unassigned", or "declared and explicitly assigned to `undefined`").
  #
  # This rule is disabled because it promotes referencing `undefined` implicitly
  # instead of explicitly. The argument in favor of implicitness is that
  # `undefined` can be redefined or shadowed, thus reducing correctness. But
  # starting with ES5, the global `undefined` can't be redefined, and the
  # `no-shadow-restricted-names` rule disallows shadowing `undefined`.
  # 
  # Note that the `no-void` rule disallows the use of `void`, and the
  # `init-declarations` rule disallows declaring a variable without explicitly
  # initializing it at the same time.
  no-undefined: off

  # Always use every variable and `catch`-block exception argument at least
  # once. Otherwise, it's pointless to declare them. For the same reason, use
  # every function argument at least once unless writing a callback with a
  # predefined argument order when the first argument isn't needed but one or
  # more subsequent ones are, in which case disable this rule via an inline
  # comment. This problem usually happens on accident as a result of
  # refactoring.
  no-unused-vars:
    - error
    - vars: all
      args: all
      caughtErrors: all

  # Never reference a variable, function, or class before defining it; it
  # reduces correctness, and reduces accessibility because variable hoisting
  # isn't widely understood. In the case of ES6 bindings such as `let`, it
  # throws a `ReferenceError` when executed.
  no-use-before-define:
    - error
    - functions: true
      classes: true

  ########################
  # Node.js and CommonJS #
  ########################

  # When invoking a callback function but not returning immediately thereafter,
  # always express into by disabling this rule via an inline comment; it
  # improves expressiveness by removing doubt: did the developer forget to add
  # a `return` statement after invoking the callback?
  #
  # Note that this rule only applies to callback functions assigned to function
  # arguments named "callback", "cb", and "next".
  callback-return: error

  # Feel free to conditionally require modules. This rule is disabled because
  # it's not a problem.
  global-require: off

  # When defining a function with `err` as the first argument, always add error
  # handling logic. Otherwise, it reduces correctness because errors go
  # unhandled. This problem usually happens by accident.
  handle-callback-err: error

  # Never mix require statements with other variable declarations; it reduces
  # elegance.
  no-mixed-requires:
    - error
    - grouping: false
      allowCall: true

  # Never use `new` in conjunction with a `require` statement; it reduces
  # correctness, and reduces accessibility because it's not widely understood
  # that it only works properly if parentheses are added around the require
  # statement (e.g., `const dog = new (require("./dog"));`). Instead, assign the
  # result of the `require` statement to a variable, and then use `new` in
  # conjunction with the variable.
  no-new-require: error

  # When combining strings containing parts of a directory or file path, never
  # use string concatenation; it reduces correctness because different platforms
  # use different path separators, and because it's easy to accidentally add
  # double separators. Instead, use Node's `path.join` or `path.resolve`.
  no-path-concat: error

  # When using `process.env`, always create a module wrapper around it, and
  # disable this rule at the top of the module file. Otherwise, it reduces
  # testability because it's more difficult to create a test double of a global
  # than a module.
  no-process-env: error

  # Never use `process.exit`; it reduces testability because it's difficult to
  # test a code path that immediately terminates the application. Instead, throw
  # an error.
  no-process-exit: error

  # This rule is disabled. It may be enabled in the future if there are modules
  # that are deemed important enough to disallow by default.
  no-restricted-modules: off

  # When using a synchronous I/O function, always express intent by disabling
  # this rule via an inline comment. Otherwise, it reduces performance, and
  # reduces expressiveness by creating doubt: did the developer accidentally use
  # a synchronous I/O function instead of its asynchronous counterpart? If a
  # project exclusively uses synchronous I/O, then disable this rule in the
  # local config file.
  no-sync: error

  ####################
  # Stylistic Issues #
  ####################

  # Never add spaces between array brackets and the tokens inside.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  array-bracket-spacing:
    - error
    - never
    - singleValue: false
      objectsInArrays: false
      arraysInArrays: false

  # Always add a space between each brace and the code inside when writing a
  # single-line block.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  block-spacing:
    - error
    - always

  # Always follow the one true brace style by putting the opening brace of a
  # block on the same line as its corresponding statement or declaration.
  #
  # The important thing is that this rule enforces a consistent style. The
  # options are personal preference.
  brace-style:
    - error
    - 1tbs
    - allowSingleLine: true

  # Always use camelcase instead of underscores when naming non-constants.
  #
  # The important thing is that this rule enforces a consistent style. Favoring
  # camelcase is personal preference.
  camelcase:
    - error
    - properties: always

  # Always include a comma at the end of the last item in a multiline list; it
  # improves maintainability by producing cleaner diffs when an item is added to
  # or removed from the end.
  comma-dangle:
    - error
    - arrays: always-multiline
      exports: always-multiline
      functions: always-multiline
      imports: always-multiline
      objects: always-multiline

  # Always add a space after commas instead of before.
  #
  # The important thing is that this rule enforces a consistent style. The
  # options are personal preference.
  comma-spacing:
    - error
    - after: true
      before: false

  # Always place commas after (instead of before) each item in a multiline list;
  # it improves maintainability by producing cleaner diffs when an item is added
  # to or removed from the beginning.
  comma-style:
    - error
    - last

  # Never add spaces between computed property brackets and the values inside.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  computed-property-spacing:
    - error
    - never

  # Always name a variable `self` when it's being used to capture `this`.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  consistent-this:
    - error
    - self

  # Always add a trailing newline at the end of files; it makes it easier to
  # append files as well as output files to the terminal without messing up the
  # shell prompt.
  eol-last:
    - error
    - always

  # Never add a space between a function invocation and the opening parenthesis
  # of the argument list.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  func-call-spacing:
    - error
    - never

  # When defining a function expression (other than `module.exports`) that's
  # automatically given a name in ES6 based on context, never manually give it a
  # different name; it reduces consistency. Instead, don't manually give it a
  # name at all; the one assigned automatically is sufficient.
  #
  # Note that this rule only disallows manually giving a function expression a
  # different name than the one that's automatically given in ES6 based on
  # context; it doesn't disallow manually giving it the same name.
  func-name-matching:
    - error
    - includeCommonJSModuleExports: false

  # Always manually give a name to a function expression when it's not
  # automatically given one in ES6 based on context; it improves debuggability
  # by producing more informative stack traces. Also, never manually give a name
  # to a function expression when it's automatically given one in ES6 based on
  # context; it's pointless.
  #
  # Note that this rule is disabled because it doesn't currently support the
  # desired policy. If https://github.com/eslint/eslint/pull/7244 is merged,
  # then this rule will be enabled with the `uninferred` option. Also note that
  # context-based automatic naming of functions is new to ES6.
  func-names: off

  # Always use function expressions (instead of function declarations or arrow
  # functions); compared to function declarations, they improve correctness and
  # expressiveness by allowing either `let` or `const` to be used depending on
  # whether or not the variable is later reassigned, and compared to arrow
  # functions they improve debuggability by producing more informative stack
  # traces (when a name is manually or automatically given).
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions.
  func-style:
    - error
    - expression
    - allowArrowFunctions: false

  # This rule is disabled. It may be enabled in the future if there are
  # identifiers that are deemed important enough to disallow by default.
  id-blacklist: off

  # Feel free to use identifiers of any length; even `i` is expressive enough in
  # many situations where iteration is obvious. This rule is disabled because
  # it's not a problem.
  id-length: off

  # This rule is disabled because it doesn't add enough value over other rules
  # such as `camelcase`.
  id-match: off

  # Always use two-space indentation; tabs reduce maintainability by causing
  # alignment issues across development environments. The number of spaces is
  # personal preference.
  indent:
    - error
    - 2
    - SwitchCase: 1
      VariableDeclarator: 1
      outerIIFEBody: 1
      MemberExpression: 1
      FunctionDeclaration:
        parameters: 1
        body: 1
      FunctionExpression:
        parameters: 1
        body: 1

  # This rule is disabled due to lack of jsx usage. It may be enabled in the
  # future.
  jsx-quotes: off

  # When defining properties in an object literal, never add any spaces before
  # the colon, and always add exactly one space after the colon; it improves
  # maintainability because otherwise whenever a new property is added to the
  # object with a longer name than the existing properties, all properties in
  # the object must be realigned, resulting in noisy diffs.
  #
  # Note that the `no-multi-spaces` rule also disallows the use of multiple
  # spaces.
  key-spacing:
    - error
    - afterColon: true
      beforeColon: false
      mode: strict

  # Always add a single space before and after keywords such as `if` and `else`.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  keyword-spacing:
    - error
    - after: true
      before: true

  # Feel free to add comments anywhere. This rule is disabled because it's not a
  # problem.
  line-comment-position: off

  # Always use Unix line endings; Unix is a more common development environment
  # for Node.js than Windows.
  linebreak-style:
    - error
    - unix

  # Feel free to add comments anywhere. This rule is disabled because it's not a
  # problem.
  lines-around-comment: off

  # Always add empty lines before and after directives such as `"use strict";`.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  lines-around-directive:
    - error
    - always

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-depth: off

  # Always limit lines to 80 characters.
  #
  # The important thing is that this rule enforces a consistent style. The
  # options are personal preference.
  max-len:
    - error
    - code: 80
      tabWidth: 2
      comments: 80
      ignoreComments: false
      ignoreTrailingComments: false
      ignoreUrls: false
      ignoreStrings: false
      ignoreTemplateLiterals: false

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-lines: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-nested-callbacks: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-params: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-statements: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-statements-per-line: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use. Note that the `no-ternary` rule disallows the ternary
  # operator.
  multiline-ternary: off

  # Only use `new` in conjunction with functions that begin with an uppercase,
  # and only invoke functions that begin with an uppercase by using `new`; it
  # improves consistency because there's an expectation that functions that
  # start with a capital letter are constructors, and ones that don't aren't. If
  # using a 3rd-party library that violates this expectation, then use the
  # `newIsCapExceptions` or `capIsNewExceptions` option to add an exception to
  # this rule in the local config file.
  new-cap:
    - error
    - capIsNew: true
      newIsCap: true
      properties: true

  # Always add parentheses to the end of the constructor when invoking it with
  # `new`, even if not providing any arguments; it improves consistency.
  new-parens: error

  # Always add a new line after variable declarations.
  #
  # The important thing is that this rule enforces a consistent style. The
  # option is personal preference.
  newline-after-var:
    - error
    - always

  # Always add a new line before `return` statements in multiline blocks.
  #
  # The important thing is that this rule enforces a consistent style. Favoring
  # a new line is personal preference.
  newline-before-return: error

  # When chaining multiple method calls, always put each call on a separate
  # line; it improves maintainability by producing cleaner diffs when one of the
  # calls is changed.
  newline-per-chained-call:
    - error
    - ignoreChainWithDepth: 1

  # Only use the `Array` constructor when a sparse array is needed, in which
  # case express intent by disabling this rule via an inline comment. Otherwise,
  # it reduces correctness, and reduces accessibility because it's not widely
  # understood that providing a single argument creates a sparse array of the
  # given size whereas providing multiple arguments creates an array with the
  # given elements, and reduces expressiveness by creating doubt: did the
  # developer accidentally create a sparse array instead of an array with a
  # single element? Instead, use array literal notation whenever possible.
  no-array-constructor: error

  # Don't use bitwise operators (e.g., `&` and `|`) unless necessary for a
  # reason other than elegance, in which case express intent by disabling this
  # rule via an inline comment. Otherwise, it reduces correctness, and reduces
  # accessibility because bitwise operators aren't widely understood, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # type `&` instead of `&&`?
  no-bitwise:
    - error
    - int32Hint: false

  # Feel free to use the `continue` statement. This rule is disabled because
  # it's not a problem.
  no-continue: off

  # Feel free to add comments anywhere. This rule is disabled because it's not
  # a problem.
  no-inline-comments: off

  # Never nest a lone `if` inside of an `else`'s execution block. Instead, use
  # `else if`.
  #
  # The important thing is that this rule enforces a consistent style. Favoring
  # `else if` is personal preference.
  no-lonely-if: error

  # When combining binary expressions of varying precedence, always add extra
  # parentheses; it increases correctness, and increases expressiveness by
  # removing doubt: did the developer fully understand order of operations?
  no-mixed-operators:
    - error
    - allowSamePrecedence: true

  # Never mix tabs and spaces; it reduces maintainability by causing alignment
  # issues across development environments. Instead, always use spaces.
  #
  # Note that the `no-tabs` rule disallows the use of tabs.
  no-mixed-spaces-and-tabs: error

  # Never put more than one empty line in a row.
  #
  # The important thing is that this rule enforces a consistent style. The max
  # number of empty lines is personal preference.
  no-multiple-empty-lines:
    - error
    - max: 1

  # Never negate conditions when writing an `if`/`else` statement or a ternary
  # expression. Instead, invert the condition.
  #
  # The important thing is that this rule enforces a consistent style.
  no-negated-condition: error

  # Never use a nested ternary expression; it reduces correctness and
  # expressiveness, and reduces accessibility because the ternary operator isn't
  # widely understood, especially when nested. Instead, use an expressive
  # alternative, such as nested `if`/`else` statements.
  #
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  no-nested-ternary: error

  # Never create an object using `new Object();`; it reduces elegance. Instead,
  # use an object literal.
  no-new-object: error

  # Don't use unary operators such as `++` unless writing the final expression
  # in a `for` statement; they reduce correctness and expressiveness, and reduce
  # accessibility because it's not widely understood how white space and
  # automatic semicolon injection can change the meaning of expressions that
  # contain unary operators. Instead, use `+=`.
  no-plusplus:
    - error
    - allowForLoopAfterthoughts: true

  # Never use an arrow function; it reduces debuggability by producing a less
  # informative stack trace. Instead, use a function expression, and manually
  # give it a name when it's not automatically given one in ES6 based on
  # context.
  #
  # Note that the `func-style` rule enforces the use of function expressions
  # over function declarations and arrow functions.
  no-restricted-syntax:
    - error
    - ArrowFunctionExpression

  # Never use tabs; they reduce maintainability by causing alignment issues
  # across development environments. Instead, always use spaces.
  no-tabs: error

  # Never use the ternary operator; it reduces correctness and expressiveness,
  # and reduces accessibility because it's not widely understood. Instead, use
  # an expressive alternative, such as `if`/`else`.
  no-ternary: error

  # Never add extra spaces to the end of a line; it's pointless. This problem
  # usually happens on accident.
  no-trailing-spaces:
    - error
    - skipBlankLines: false

  # Feel free to use dangling underscores in identifiers. This rule is disabled
  # because it's not a problem.
  no-underscore-dangle: off

  # Never use a ternary expression in a situation that has an easier alternative
  # (e.g., `let foo = bar ? bar : 1;` is better expressed as
  # `let foo = bar || 1;`); it reduces correctness and expressiveness, and
  # reduces accessibility because the ternary operator isn't widely understood.
  # 
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  no-unneeded-ternary:
    - error
    - defaultAssignment: false

  # Never add whitespace around the dot or before the bracket of object
  # properties (except when indenting on a new line).
  #
  # The important thing is that this rule enforces a consistent style. Favoring
  # no whitespace is personal preference.
  no-whitespace-before-property: error

  # Always be consistent when adding new lines after properties in an object
  # literal or destructuring assignment; it improves readability. If all
  # properties fit on the same line, then put them on the same line. Otherwise,
  # put each property on its own line.
  #
  # Note that the `object-property-newline` rule enforces a similar style.
  object-curly-newline:
    - error
    - multiline: true

  # Never add spaces between object literal and destructuring assignment braces,
  # and the tokens inside; it's harder to type, and it doesn't improve
  # readability.
  object-curly-spacing:
    - error 
    - never

  # Always be consistent when adding new lines after properties in an object
  # literal; it improves readability. If all properties fit on the same line,
  # then put them on the same line. Otherwise, put each property on its own
  # line.
  #
  # Note that the `object-curly-newline` rule enforces a similar style.
  object-property-newline:
    - error
    - allowMultiplePropertiesPerLine: true

  # Always use a separate declaration for each variable; it improves readability
  # as well as diffs when changes are made.
  one-var:
    - error
    - never

  # Always put each variable declaration on its own line; it improves
  # readability as well as diffs when changes are made.
  #
  # Note that the `one-var` rule enforces a separate declaration to be made for
  # each variable, whereas this rule only addresses multi-variable declarations.
  # Therefore, this rule is only enabled in case the `one-var` rule is disabled.
  one-var-declaration-per-line:
    - error
    - always

  # Always use shorthand operators such as `+=` for simple math operations; it
  # improves readability.
  operator-assignment:
    - error
    - always

  # Always place the operator at the end of the current line instead of the
  # start of the next line when breaking an expression across multiple lines;
  # it improves readability by signaling that the expression continues on the
  # next line.
  operator-linebreak:
    - error
    - after

  # Never add empty lines as padding inside of blocks; it takes up more space
  # without improving readability.
  padded-blocks:
    - error
    - never

  # Only put quotes around property names when required. Otherwise, it decreases
  # readability without adding value.
  quote-props:
    - error
    - as-needed

  # Always use double quotes unless embedding an expression, in which case use
  # a template literal; double quotes are consistent with JSON, and single
  # quotes look too similar to backticks.
  quotes:
    - error
    - double
    - allowTemplateLiterals: true
      avoidEscape: false

  # This rule is disabled due to lack of jsdoc usage. It may be enabled in the
  # future.
  require-jsdoc: off

  # Never add a space before semicolons; it reduces readability. Also, always
  # add a space after semicolons when they're not at the end of a line; it
  # improves readability.
  semi-spacing:
    - error
    - after: true
      before: false
 
  # Always add a semicolon at the end of each statement (except when the full
  # statement is inside braces on a single line); it improves readability in
  # much the same way that periods at the end of each sentence improves
  # readability in the English language. In rare situations, it also avoids
  # unexpected behavior due to automatic semicolon insertion.
  semi:
    - error
    - always
    - omitLastInOneLineBlock: true

  # Feel free to sort object properties in whichever order that makes sense.
  # This rule is disabled because it's not a problem.
  sort-keys: off

  # Feel free to sort variable declarations in whichever order that makes sense.
  # This rule is disabled because it's not a problem.
  sort-vars: off

  # Always add a space before blocks; it improves readability.
  space-before-blocks:
    - error
    - always

  # Always add a space before the opening parenthesis in a function definition;
  # it helps distinguish a function definition from a function call.
  space-before-function-paren:
    - error
    - anonymous: always
      asyncArrow: always
      named: always

  # Never add spaces between parentheses and the contents inside; it's harder to
  # type, and it doesn't improve readability.
  space-in-parens:
    - error
    - never

  # Always add spaces around operators such as `+`; it improves readability.
  space-infix-ops:
    - error
    - int32Hint: false

  # Always add spaces after unary word operators such as `new` and `delete`; it
  # improves readability. Never add unnecessary spaces around unary non-word
  # operators such as `++`; it reduces readability without adding value.
  space-unary-ops:
    - error
    - words: true
      nonwords: false

  # Always add a space after the opening `//` or `/*` in a comment, and before
  # the closing `*/` when it's on the same line; it improves readability.
  spaced-comment:
    - error
    - always
    - block:
        balanced: true

  # Never specify whether or not a code unit is big or little endian; it's not
  # relevant when using UTF-8 encoding.
  unicode-bom:
    - error
    - never

  # Never wrap regex literals in parentheses; it reduces readability without
  # adding value.
  #
  # This rule is disabled because it's not a problem.
  wrap-regex: off

  ################
  # ECMAScript 6 #
  ################

  # Never use braces in conjunction with an arrow function; it adds more
  # complexity than value. If braces aren't needed, then remove them. If braces
  # are needed, then use a named function expression instead.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-body-style:
    - error
    - never

  # Only add parentheses around an arrow function's arguments when there's more
  # than one. Otherwise, it reduces readability without adding value.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-parens:
    - error
    - as-needed
    - requireForBlockBody: false

  # Always add a space before and after the `=>` when defining an arrow
  # function; it improves readability.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-spacing:
    - error
    - after: true
      before: true

  # Always call `super()` from within the constructors of derived classes.
  # Otherwise, it throws an error upon execution.
  constructor-super: error

  # Always add a space after the star, not before, when defining a generator
  # function; it improves readability.
  generator-star-spacing:
    - error
    - after: true
      before: false

  # Never reassign a class; there's an expectation that a class can always be
  # created by name once defined.
  no-class-assign: error

  # Never define an arrow function in a place where it can be confused with a
  # `>=` comparison operator; it reduces readability and creates doubt about
  # whether or not it's intentional. Instead, use a regular function.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  no-confusing-arrow:
    - error
    - allowParens: false

  # Never reassign a variable defined via `const`; it'll throw an error upon
  # execution. Instead, define the variable via `let`. It's common to forget
  # that a variable was defined via `const` instead of `let`.
  no-const-assign: error

  # Never define a class that has multiple properties with the same name; the
  # last occurrence shadows the one(s) before it.
  no-dupe-class-members: error

  # Always use a single `import` statement per module unless exporting from an
  # imported module, in which case the export should occur in a separate
  # statement. Otherwise, it adds complexity without value.
  no-duplicate-imports:
    - error
    - includeExports: false

  # Never use `new` when creating a `Symbol`; it's designed to be called as a
  # function.
  no-new-symbol: error

  # This rule is disabled. It may be enabled in the future if there are modules
  # that are deemed important enough to disallow by default.
  no-restricted-imports: off

  # Never reference `this` before `super` in the constructor of a derived class;
  # it throws a `ReferenceError`.
  no-this-before-super: error

  # Never use a computed property when it could be expressed as a non-computed
  # property; it adds complexity without value.
  no-useless-computed-key: error

  # Never define a class constructor if the implicit default constructor is
  # identical; it adds complexity without value.
  no-useless-constructor: error

  # Never rename a reference without actually changing the name when
  # destructing, importing, or exporting; it adds complexity without value.
  no-useless-rename:
    - error
    - ignoreDestructuring: false
      ignoreExport: false
      ignoreImport: false

  # Never use `var` to declare a variable; it leads to unexpected behavior due
  # to hoisting and not being block scoped. Instead, use `let` or `const`.
  no-var: error

  # Always use object shorthand syntax when possible; it improves readability.
  object-shorthand:
    - error
    - always
    - avoidQuotes: false
      ignoreConstructors: false

  # Only use an arrow function to return a single-line expression, and only when
  # it won't noticeably impact stack trace debugging. In all other situations,
  # use a function expression; it improves readability and stack traces.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is disabled because arrow functions should be used
  # sparingly if the `no-restricted-syntax` rule is enabled. In most situations,
  # the cost of using them is greater than the benefit.
  prefer-arrow-callback: off

  # Always use `const` instead of `let` when the variable isn't reassigned; it's
  # more expressive and protects against accidental reassignment.
  prefer-const:
    - error
    - destructuring: any
      ignoreReadBeforeAssign: false

  # Never use `parseInt` with a radix value of `2`, `8`, or `16`. Instead, use
  # the binary, octal, and hexadecimal literals added in ES6; they're more
  # expressive.
  prefer-numeric-literals: error

  # Always prefer ES6 `Reflect` methods over their pre-ES6 alternatives; they
  # more closely represent the inner workings of JavaScript without sacrificing
  # readability.
  prefer-reflect: error

  # Always use rest parameters (e.g., `...`) instead of `arguments` when
  # converting a list of arguments into a single variable; unlike `arguments`,
  # it creates a proper array, and also adds flexibility in choosing which
  # arguments are converted.
  prefer-rest-params: error

  # Always use the spread operator (e.g., `...vals`) to convert an array into a
  # list of arguments when passing them to a function, instead of calling the
  # function via `.apply`; it's more expressive, and also adds flexibility in
  # choosing which arguments are converted.
  prefer-spread: error

  # Always use template literals instead of string concatenation when embedding
  # expressions into a string; it's more expressive, and it improves
  # readability.
  prefer-template: error

  # Never define a generator function that doesn't call `yield`; it's pointless.
  # Instead, use a regular function.
  require-yield: error

  # Never add a space between the spread operator and its expression; it reduces
  # readability without adding value.
  rest-spread-spacing:
    - error
    - never

  # Feel free to sort imports in whichever order that makes sense. This rule is
  # disabled because it's not a problem.
  sort-imports: error

  # Always provide a description when defining a `Symbol`; it improves
  # debugging.
  symbol-description: error

  # Never add spaces between template literal braces and the expression inside;
  # it's harder to type, and it doesn't improve readability.
  template-curly-spacing:
    - error
    - never

  # Always add a space after the star, not before, when using the `yield`
  # statement; it improves readability.
  yield-star-spacing:
    - error
    - after: true
      before: false

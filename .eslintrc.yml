parserOptions:
  ecmaVersion: 2017
env:
  es6: true
rules:
  ###################
  # Possible Errors #
  ###################

  # Never put an assignment expression inside of a conditional; it reduces
  # correctness because it's an easy mistake to type `=` instead of `===`, and
  # reduces expressiveness because it's unclear whether or not it's intentional.
  #
  # The `always` option is set instead of the default `except-parens` option
  # because wrapping the assignment in an extra set of parentheses doesn't
  # sufficiently express intent.
  no-cond-assign:
    - error
    - always

  # Don't release code containing a `console` statement unless in a development
  # environment, in which case set this rule to `warn` instead of `error` in the
  # local config file so that the build doesn't fail but reminders are still
  # provided. Otherwise, it reduces security by leaking debugging information to
  # users.
  no-console: error

  # When using a constant expression as a conditional, always express intent by
  # disabling this rule via an inline comment. Otherwise, it reduces correctness
  # because it's easy to make a mistake in logic that results in an infinite
  # loop, and reduces expressiveness because it's unclear whether or not it's
  # intentional.
  no-constant-condition:
    - error
    - checkLoops: true

  # When using control characters in regular expressions, always express intent
  # by disabling this rule via an inline comment. Otherwise, it reduces
  # correctness because it's an easy mistake to type a control character, and
  # reduces expressiveness because it's unclear whether or not it's intentional.
  # If frequent use of control characters is expected in a project, then disable
  # this rule in the local config file.
  no-control-regex: error

  # Don't release code containing a `debugger` statement unless in a development
  # environment, in which case set this rule to `warn` instead of `error` in the
  # local config file so that the build doesn't fail but reminders are still
  # provided. Otherwise, it reduces security by leaking debugging information to
  # users.
  no-debugger: error

  # Never define a function that has multiple arguments with the same name; it's
  # pointless because the last occurrence shadows the one(s) before it. This
  # problem usually happens on accident.
  no-dupe-args: error

  # Never define an object literal that has multiple properties with the same
  # name; it's pointless because the last occurrence shadows the one(s) before
  # it. This problem usually happens on accident.
  no-dupe-keys: error

  # Never define a `switch` statement that has multiple cases with the same
  # clause; it's pointless because the first occurrence is the only one that'll
  # ever be matched. This problem usually happens on accident.
  no-duplicate-case: error

  # When writing an empty code block, always express intent by adding a comment
  # inside. Otherwise, it reduces expressiveness: did the developer accidentally
  # leave behind an empty block after refactoring?
  no-empty:
    - error
    - allowEmptyCatch: false

  # Never include empty brackets in a regular expression; it's pointless because
  # an empty character set doesn't match anything. If needing to include "[]" as
  # part of the pattern, then escape each bracket. This problem usually happens
  # on accident.
  no-empty-character-class: error

  # Never reassign the exception parameter in a `catch` block; it reduces
  # correctness because it's an easy mistake to reassign it since it's not
  # protected via `const`, and reduces debuggability because the original error
  # might be lost, and reduces consistency by defying the expectation that the
  # exception parameter will always reference the caught error. Instead, assign
  # the exception to a separate variable that can later be reassigned as
  # necessary.
  no-ex-assign: error

  # Never cast a variable to a boolean as part of a test condition; it's
  # pointless because it's done automatically by the engine. This problem
  # usually happens as a misguided attempt to add expressiveness where none is
  # needed.
  no-extra-boolean-cast: error

  # When combining binary expressions of varying precedence, always add extra
  # parentheses. Otherwise, it reduces correctness because it's an easy mistake
  # to mix up the order of operations, and reduces expressiveness: did the
  # developer understand the order of operations when writing it? Also, never
  # add extra parentheses in other situations; it reduces elegance as part
  # of a misguided attempt to add expressiveness where none is needed.
  #
  # Note that the `no-mixed-operators` rule enforces the use of extra
  # parentheses when combining binary expressions of varying precedence. This
  # rule merely gets out of the way of the `no-mixed-operators` rule while also
  # preventing extra parentheses in other situations.
  no-extra-parens:
    - error
    - all
    - conditionalAssign: false
      nestedBinaryExpressions: true
      returnAssign: false

  # Never put semicolons anywhere that not even automatic semicolon insertion
  # would add one; it's pointless. This problem usually happens on accident by
  # typing `;;` instead of `;`, or by adding a `;` after the closing brace of a
  # function declaration.
  no-extra-semi: error

  # Never reassign a function declaration; it reduces correctness because it's
  # an easy mistake to reassign a function declaration since it's not protected
  # via `const`, and reduces debuggability because it's sometimes difficult to
  # realize that a function declaration has been reasssigned, and reduces
  # consistency by defying the expectation that a function defined in this
  # manner will never be reassigned. Instead, assign a function expression to a
  # variable using `let` so that it can later be reassigned as necessary.
  #
  # Note that the `func-style` rule enforces the use of function expressions
  # over function declarations and arrow functions. This rule is only enabled in
  # case the `func-style` rule is disabled.
  no-func-assign: error

  # Feel free to use function declarations in nested blocks; starting with ES6,
  # function declarations are appropriately block-scoped. Better yet, use a
  # function expression; it improves consistency.
  # 
  # This rule is disabled because it only applies to pre-ES5 environments. Note
  # that the `func-style` rule enforces the use of function expressions over
  # function declarations and arrow functions. Also, the `no-var` rule enforces
  # the use of  `let` and `const` over `var`.
  no-inner-declarations: off

  # Never put an invalid regular expression inside of a `RegExp` constructor; it
  # throws a `SyntaxError` when executed. This problem usually happens on
  # accident.
  no-invalid-regexp: error

  # Don't use non-standard whitespace characters unless necessary for a reason
  # other than elegance, in which case express intent by disabling this rule via
  # an inline comment. Otherwise, it reduces correctness because it's an easy
  # mistake to copy and paste a non-standard whitespace character which can lead
  # to unexpected results during string comparisons, and reduces expressiveness 
  # because it's unclear whether or not it's intentional, and reduces
  # debuggability because it's not visually obvious that a non-standard
  # whitespace character is present.
  no-irregular-whitespace:
    - error
    - skipStrings: false
      skipComments: false
      skipRegExps: false
      skipTemplates: false

  # Never invoke non-function global objects such as `Math` or `JSON` as if
  # they're functions; it throws a `TypeError` when executed. This problem
  # usually happens on accident.
  no-obj-calls: error

  # Never directly invoke an `Object.prototype` method on an object; it reduces
  # correctness because it's possible for such methods to be shadowed, or for an
  # object to not even have `Object.prototype` in its prototype chain. Instead,
  # use `call`, or wrap them in stand-alone helper functions.
  no-prototype-builtins: error

  # Never chain multiple spaces together in a regex; it reduces correctness
  # because it's an easy mistake to type `  ` instead of ` `, and reduces
  # expressiveness because it's unclear whether or not it's intentional.
  # Instead, use a single space followed by `{n}` where `n` is the number of
  # spaces.
  no-regex-spaces: error

  # When creating a sparse array via an array literal, always express intent by
  # disabling this rule via an inline comment. Otherwise, it reduces correctness
  # because it's an easy mistake to type `,,` instead of `,`, and reduces 
  # expressiveness because it's unclear whether or not's intentional, and
  # reduces accessibility because it's not widely understood that a sparse array
  # is created when an extra comma is added in an array literal. Better yet,
  # don't use sparse arrays at all; they're not widely understood.
  no-sparse-arrays: error

  # Don't put a template literal placeholder such as `${var}` inside of a
  # single- or double-quoted string unless necessary for a reason other than
  # elegance, in which case express intent by disabling this rule via an inline
  # comment. Otherwise, it reduces correctness because it's an easy mistake to
  # use single or double quotes instead of backticks, and reduces expressiveness
  # because it's unclear whether or not it's intentional.
  no-template-curly-in-string: error

  # Never split an expression across multiple lines in such a way that the
  # newline looks like it's ending the statement when it's not; it reduces
  # correctness because it's an easy mistake to write incorrect logic due to
  # automatic semicolon insertion, and reduces expressiveness because it's
  # unclear whether or not it's intentional, and reduces accessibility because
  # automatic semicolon insertion isn't widely understood.
  no-unexpected-multiline: error

  # Never put code after an unconditional exit statement; it's pointless because
  # it's never executed. This problem usually happens on accident.
  no-unreachable: error

  # Never put a control flow statement such as `return` inside of a `finally`
  # block; it reduces accessibility because it's not widely understood that
  # control flow statements inside of a `finally` block take priority over
  # control flow statement inside of a `try` or `catch` block, and reduces
  # correctness because it's easy to forget that rule and make a mistake.
  no-unsafe-finally: error

  # Never negate the left operand when using `in` or `instanceof`; it reduces
  # correctness because it's an easy mistake to only negate the left operand
  # instead of the full expression which results in faulty logic, and reduces
  # expressiveness because it's unclear whether or not it's intentional.
  no-unsafe-negation: error

  # Never compare a value to `NaN`; it reduces accessibility because it's not
  # widely understood that `NaN` is the only value in JavaScript that's not
  # equal to itself, and reduces correctness because it's easy to forget that
  # rule and make a mistake. Instead, use `isNaN` or `Number.isNaN`.
  use-isnan: error

  # This rule is disabled due to lack of jsdoc usage. It may be enabled in the
  # future.
  valid-jsdoc: off

  # Never compare a `typeof` expression to any string literal other than one of
  # the valid types; it's pointless because it always fails.
  #
  # The `requireStringLiterals` option is set to `false` because comparing a
  # `typeof` expression to a variable is a normal thing to do, and it doesn't
  # inherently reduce correctness.
  valid-typeof:
    - error
    - requireStringLiterals: false

  ##################
  # Best Practices #
  ##################

  # Never define a setter via `set` without a corresponding getter, or
  # vice-versa; it reduces testability because it often leads to unverifiable
  # results, and reduces consistency by defying the expectation that a property
  # that can be assigned a value via an assignment operator can also have the
  # value retrieved via simple property access, and vice-versa.
  accessor-pairs:
    - error
    - setWithoutGet: true
      getWithoutSet: true
  
  # When invoking Array's map/reduce methods, always return a value in the
  # callback. Otherwise, it reduces correctness because such methods rely on a
  # return value in order to complete their task, but it's an easy mistake to
  # forget to add a `return` statement. If the method was just being used to
  # invoke a function for each entry in an array, then use
  # `Array.prototype.forEach` instead.
  array-callback-return: error

  # Never use a variable defined via `var` outside of the block in which it was
  # defined; it reduces accessibility because it's not widely understood that
  # variables defined via `var` are hoisted and aren't block-scoped, and reduces
  # correctness because it's easy to forget about those concepts and make a
  # mistake. Instead, move the `var` statement to the top of the variable scope.
  # Or better yet, use `let` or `const` instead; they're both block-scoped.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  block-scoped-var: error

  # Never define a class method that doesn't reference `this`; it reduces
  # correctness because it's an easy mistake to reference a local variable
  # instead of an instance property, and reduces expressiveness because it's
  # unclear whether or not it's intentional. Instead, use a static class
  # function. Better yet, don't use classes or `this` at all; they reduce
  # correctness, expressiveness, and accessibility due to the ambiguity of
  # `this`.
  class-methods-use-this: error

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  complexity: off

  # Never define a function that returns a value in one code path but not
  # another; it reduces correctness because it's easy to forget to add a
  # `return` statement at the end of a function, and reduces expressiveness
  # because it's unclear whether or not it's intentional. If one code path needs
  # to return a value, but another doesn't, then express intent by having the
  # latter return `null` instead of `undefined`. Otherwise, it reduces
  # correctness, debuggability, expressiveness, and accessibility due to the
  # ambiguity of `undefined` (which can mean either "undeclared", "declared but
  # unassigned", or "declared and explicitly assigned to `undefined`").
  consistent-return:
    - error
    - treatUndefinedAsUnspecified: false

  # Always put braces around conditional execution blocks, and always put the
  # execution block on its own line(s), even if it'd fit on the same line as the
  # conditional.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. It
  # also slightly improves maintainability by producing cleaner diffs when a
  # change is made to either the condition or the execution block, especially
  # when the change involves resizing the execution block from one line to many,
  # or vice versa.
  curly:
    - error
    - all

  # When defining a `switch` block without a default case, always add a
  # `// no default` comment at the bottom. Otherwise, it reduces correctness
  # because it's easy to forget to add a `default` case, and reduces
  # expressiveness because it's unclear whether or not it's intentional.
  default-case: error

  # Always place the dot at the beginning of the property (instead of at the end
  # of the object) in multiline member expressions.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. It
  # also slightly improves elegance by avoiding confusion caused by the role of
  # periods in the English language to indicate the end of a sentence.
  dot-location:
    - error
    - property

  # When accessing object properties, only use bracket notation when necessary,
  # such as when the key is a `Symbol` or variable. Otherwise, use dot notation.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  # Note that the `allowKeywords` option is set to `true` because maintaining
  # ES3 compatibility usually isn't a requirement. If it's a requirement, then
  # set `allowKeywords` to `false` in the local config file.
  dot-notation:
    - error
    - allowKeywords: true

  # Always use `===` instead of `==`. Otherwise, it reduces correctness because
  # it's an easy mistake to type `==` instead of `===`, and reduces
  # expressiveness because it's unclear whether or not it's intentional, and
  # reduces accessibility because the rules of `==` regarding type coercion
  # aren't widely understood.
  eqeqeq:
    - error
    - always
    - null: always

  # When looping through keys via `for`/`in`, filter out inherited properties
  # via `Object.prototype.hasOwnProperty` unless inherited properties are
  # necessary, in which case express intent by disabling this rule via an
  # inline comment. Otherwise, it reduces correctness because it's easy to
  # forget to filter out inherited properties, and reduces expressiveness
  # because it's unclear whether or not it's intentional, and reduces
  # accessibility because it's not widely understood that `for`/`in` includes
  # inherited properties.
  guard-for-in: error

  # Never use `alert`, `prompt`, or `confirm`; they create a poor user
  # experience. Instead, use a custom UI widget.
  no-alert: error

  # Never use `arguments.caller` or `arguments.callee`; they're deprecated.
  # Instead of using `arguments.caller`, the called function should accept the
  # calling function as a parameter. Instead of using `arguments.callee`, the
  # function should just reference itself by name.
  no-caller: error

  # When writing a `case` execution block containing a lexical declaration,
  # always put braces around the block. Otherwise, it reduces accessibility
  # because it's not widely understood that the variable will be scoped to the
  # entire `switch` block instead of only the `case`'s execution block, and
  # reduces correctness because it's easy to forget about that rule and make a
  # mistake.
  no-case-declarations: error

  # Don't bother escaping an equal sign at the start of a regex literal; it's
  # pointless, and the rest of the line provides sufficient context to avoid
  # ambiguity with a division operator.
  #
  # This rule is highly subjective. It's disabled because it's considered a
  # misguided attempt at improving correctness and expressiveness at the cost of
  # elegance when no improvement is needed.
  no-div-regex: off

  # Don't define an `else` block if the `if` block always returns when executed;
  # it's pointless because the code after the `if` block will only be executed
  # if the `if` block wasn't executed, regardless of whether or not it's wrapped
  # in an `else` block. Instead, put the code outside, directly after the end of
  # the `if` block; it slightly improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-else-return: error

  # When defining an empty function, always express intent by adding a comment
  # inside of the function body. Otherwise, it reduces expressiveness: did the
  # developer accidentally leave behind an empty function after refactoring?
  #
  # It'd be nice if there was an option in ESLint to allow a function named
  # "noop" to be empty without needing a comment, since the name expresses
  # intent.
  no-empty-function: error

  # Never define an empty pattern (e.g., `let {a: {}} = obj`) when
  # destructuring; it's pointless because no properties are ever assigned. If
  # setting the default value of a property to an empty object, then type `=`
  # instead of `:` (e.g., `let {a = {}} = obj`). This problem usually happens on
  # accident.
  no-empty-pattern: error

  # When comparing a value against `null`, always use `===` instead of `==`.
  # Otherwise, it reduces accessibility because it's not widely understood that
  # `true` will be returned if the value is either `null` or `undefined`, and
  # reduces correctness because it's easy to forget that rule and make a
  # mistake, and reduces expressiveness because it's unclear whether or not it's
  # intentional. If testing for both `null` or `undefined`, then express intent
  # by performing two separate comparisons using `===`.
  #
  # Note that the `eqeqeq` rule enforces the use of `===` over `==`. This rule
  # is only enabled in case the `eqeqeq` rule is disabled.
  no-eq-null: error

  # Never use `eval`; it reduces security by opening the door for injection
  # attacks, and reduces performance.
  no-eval:
    - error
    - allowIndirect: false

  # Never modify native objects such as `Object`; it reduces consistency by
  # defying the expectation that native objects always behave the same way
  # across projects, and reduces correctness because it breaks code that relies
  # on the default implementation.
  no-extend-native: error

  # Never create a new function with `bind` if the new function doesn't use
  # `this` or perform argument binding, or if the target function is an arrow
  # function; it's pointless because it adds no functionality over the unbound
  # version.
  no-extra-bind: error

  # Only use a label in a loop or switch if it's nested, and only if it's
  # necessary for a reason other than elegance. Otherwise, it reduces
  # consistency because it defies the expectation of how labels should be used,
  # and reduces accessibility because labels aren't widely used.
  #
  # Note that the `no-labels` rule disallows the use of labels except in loops.
  no-extra-label: error

  # Never use fall-through logic in a `switch` block unless necessary for a
  # reason other than elegance, in which case express intent by adding a
  # `// fall through` comment at the end of the `case` block. Otherwise, it
  # reduces correctness because it's easy to forget to add a `break` statement
  # at the end of a `case` block, and reduces expressiveness because it's
  # unclear whether or not it's intentional.
  no-fallthrough: error

  # Never leave either side of the decimal point blank in a decimal number.
  # Instead, add a zero (e.g., `0.3` instead of `.3`, and `3.0` instead of
  # `3.`); it slightly improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-floating-decimal: error

  # Never reassign built-in global variables; it reduces consistency by defying
  # defying the expectation that built-in global variables always behave the
  # same way across projects, and reduces correctness because it breaks code
  # that relies on the default implementation.
  no-global-assign: error

  # Always perform coercions explicitly (e.g., `Boolean(val)`) instead of
  # implicitly (e.g., `!!val`); it improves correctness because it's an easy
  # mistake to type `!!` instead of `!`, and improves expressiveness because
  # it's unclear whether or not it's intentional, and improves accessibility
  # because operators such as `~` aren't widely understood.
  no-implicit-coercion:
    - error
    - boolean: true
      number: true
      string: true

  # Only declare a `var` or function declaration in the global scope when
  # necessary for a reason other than elegance, in which case express intent by
  # explicitly assigning it to the global object (e.g., `window` in the browser,
  # or `global` in Node.js`). Otherwise, it reduces accessibility because it's
  # not widely understood that top-level `var` and function declarations are
  # added as properties to the global object, and reduces correctness because
  # it's easy to forget that rule and make a mistake, and reduces expressiveness
  # because it's unclear whether or not it's intentional.
  #
  # Note that the `func-style` enforces the use of function expressions over
  # function declarations and arrow functions. Also, the `no-var` rule enforces
  # the use of `let` and `const` over `var`.
  no-implicit-globals: error

  # Never indirectly invoke `eval`-like behavior, such as by passing code as the
  # first argument to `setTimeout`; it reduces security by opening the door for
  # injection attacks, and reduces performance.
  no-implied-eval: error

  # Don't use `this` outside of expected blocks, such as constructors and object
  # methods, unless necessary for a reason other than elegance, in which case
  # disable this rule via an inline comment. It reduces expressiveness because
  # it's unclear what `this` represents in such a context, and reduces
  # correctness because it's an easy mistake to use the function the wrong way
  # by providing the wrong value for `this`, and reduces consistency because it
  # defies the expectation of how `this` is normally reserved for constructors
  # and object methods. Better yet, don't use classes or `this` at all; they
  # reduce correctness, expressiveness, and accessibility due to the ambiguity
  # of `this`. 
  no-invalid-this: error

  # Never use the __iterator__ property; it's deprecated. Instead, use ES6
  # ES6 iterators and generators.
  no-iterator: error

  # Only use labels in conjunction with nested loops, and only when necessary.
  # Otherwise, it reduces consistency because it defies the expectation of how
  # labels should be used, and reduces accessibility because labels aren't
  # widely used.
  #
  # Note that the `no-extra-label` rule disallows the use of labels in
  # non-nested loops.
  no-labels:
    - error
    - allowLoop: true
      allowSwitch: false

  # Don't create standalone code blocks unless necessary for a reason other than
  # elegance, in which case express intent by disabling this rule via an inline
  # comment. Otherwise, it reduces expressiveness: did the developer
  # accidentally leave behind a standalone code block after refactoring? There's
  # rarely a compelling reason to create a standalone code block on purpose.
  no-lone-blocks: error

  # Don't define functions inside of loops unless necessary for a reason other
  # than elegance, in which case express intent by disabling this rule via an
  # inline comment. Otherwise, it reduces accessibility because it's not widely
  # understood that all instances of an inner function will reference the same
  # outer incremental variable declared via `var`, and reduces correctness
  # because it's easy to forget that rule and make a mistake, and reduces
  # expressiveness because it's unclear whether or not it's intentional, and
  # reduces performance because the same function is redefined many times.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`.
  no-loop-func: error

  # Only use numbers explicitly when accessing array elements. In other
  # situations, assign numbers to descriptively named constants or properties.
  # Otherwise, it reduces expressiveness and accessibility because it's not
  # always obvious what the numbers represent. If this rule proves too onerous,
  # then disable it in the local config file.
  #
  # It'd be nice if the `ignoreArrayIndexes` option also applied to `indexOf`.
  no-magic-numbers:
    - error
    - detectObjects: false
      enforceConst: true
      ignoreArrayIndexes: true

  # Don't chain multiple spaces together for purposes other than indentation; it
  # reduces maintainability, especially when adding spaces to align object
  # property values across multiple lines, because whenever a new property is
  # added to the object with a longer name than the existing properties, all
  # properties in the object must be realigned, resulting in noisy diffs.
  #
  # Note that the `key-spacing` rule also prevents multiple spaces from being
  # added after the colon in object property values. This rule prevents multiple
  # spaces everywhere.
  no-multi-spaces:
    - error
    - exceptions:
        Property: false

  # Never create multiline strings by putting `\` at the end of each line.
  # Instead, use string concatenation or template literals; it slightly improves
  # elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-multi-str: error

  # Never create functions using `new Function()`; it reduces security by
  # opening the door for injection attacks, and reduces performance.
  no-new-func: error

  # Never create primitives via `new String`, `new Number`, or `new Boolean`; it
  # reduces accessibility because it's not widely understood that they're
  # considered objects, causing `typeof` to return "object", and
  # `new Boolean(false)` to resolve to `true`. It also reduces correctness
  # because it's easy to forget that rule and make a mistake.
  no-new-wrappers: error

  # When using `new` but not assigning the result to a variable, always express
  # intent by disabling this rule via an inline comment. Otherwise, it reduces
  # correctness because it's easy to forget to assign the result of the
  # constructor invocation to a variable, and reduces expressiveness because
  # it's unclear whether or not it's intentional, and reduces consistency
  # because it defies the expectation of how `new` is normally used.
  no-new: error

  # Never use octal escape sequences in string literals; they're deprecated in
  # ES5. Instead, use unicode escape sequences.
  no-octal-escape: error

  # Never use octal literals (e.g., `071`); they're deprecated in ES5.
  no-octal: error

  # Never reassign a function argument; it reduces correctness because it's an
  # easy mistake to reassign them since they're not protected via `const`, and
  # reduces expressiveness because it's unclear whether or not it's intentional,
  # and reduces consistency because it defies the expectation that an argument
  # always references the variable that was passed in when the function was
  # invoked. Instead, assign the argument to a local variable that can later be
  # reassigned as necessary.
  #
  # The `props` option is set to `false` because although it improves
  # correctness to treat all arguments as immutable, doing so significantly
  # reduces accessibility, elegance, and performance due to the difficulty and
  # implications of practicing a purely functional programming style. If the
  # costs are worth the benefit, then set the `props` option to `true` in the
  # local config file.
  no-param-reassign:
    - error
    - props: false

  # Never use the `__proto__` property; it's deprecated in ES3.1. Instead, use
  # `Object.getPrototypeOf`.
  no-proto: error

  # Never redeclare a variable using `var`; it's pointless. Instead, just
  # reassign the previously declared variable. Even better, use `let` instead of
  # `var`. 
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  no-redeclare:
    - error
    - builtinGlobals: true

  # This rule is disabled. It may be enabled in the future if there are
  # properties that are deemed important enough to disallow by default.
  no-restricted-properties: off

  # Never return an assignment expression; it reduces correctness because it's
  # an easy mistake to type `=` instead of `===`, and reduces expressiveness
  # because it's unclear whether or not it's intentional, and reduces
  # accessibility because it's not widely understood that the value returned
  # from an assignment expression is the value that was assigned.
  #
  # The `always` option is used instead of the `except-parens` option because
  # wrapping the assignment in an extra set of parentheses doesn't sufficiently
  # express intent.
  no-return-assign:
    - error
    - always

  # Never use `location.href = "javascript:<code>"`; it reduces security by
  # opening the door for injection attacks, and reduces performance.
  no-script-url: error

  # Never assign a variable or object property to itself; it's pointless. It's
  # common for this to be done on accident.
  no-self-assign:
    - error
    - props: true

  # Never compare a variable to itself; it reduces accessibility because it's
  # not widely understood that `NaN` is the only value in JavaScript that
  # doesn't equal itself, and reduces correctness because it's easy to forget
  # that rule and make a mistake, and reduces expressiveness because it's
  # unclear whether or not it's intentional. If testing for `NaN`, then use the
  # global `isNaN` or `Number.isNaN` functions instead.
  no-self-compare: error

  # Never use the comma operator unless defining the initialization or
  # final-expression portions of a `for` statement; it reduces accessibility
  # because it's not widely understood that the comma operator executes each
  # expression from left to right and returns the value of the last operand.
  #
  # Note that this rule doesn't apply to using commas in argument lists.
  no-sequences: error

  # Never throw any value other than an `Error` object, or an object that
  # extends `Error`; it reduces debuggability due to the lack of a stack trace,
  # and reduces consistency because it defies the expectation of what properties
  # are included in a thrown error.
  no-throw-literal: error

  # Don't create a loop with a condition that's not modified within the loop
  # unless necessary for a reason other than elegance, in which case express
  # intent by disabling this rule via an inline comment. Otherwise, it reduces
  # correctness because it's easy to make a mistake in logic that results in an
  # infinite loop, and reduces expressiveness because it's unclear whether or
  # not it's intentional.
  no-unmodified-loop-condition: error

  # Never write an expression that doesn't have any effect; it's pointless. This
  # problem usually happens on accident due to a mistake in logic.
  no-unused-expressions:
    - error
    - allowShortCircuit: false
      allowTernary: false

  # Never define a label that's never used; it's pointless. This problem usually
  # happens on accident as a result of refactoring.
  no-unused-labels: error

  # Only use `.call` or `.apply` when necessary, such as when explicitly setting
  # `this`, or, in the case of `.apply`, when passing in arguments as an array.
  # Otherwise, it's pointless because it's the same as invoking the functions
  # normally, except it reduces elegance and performance. This problem usually
  # happens on accident as a result of refactoring.
  #
  # Note that the `prefer-spread` rule enforces the use of the spread operator
  # over using `.apply`.
  no-useless-call: error

  # Only use string concatenation when necessary, such as when breaking up a
  # long string across multiple lines. Otherwise, it's pointless because it's
  # the same as putting everything inside of a single string, except it reduces
  # elegance and performance. This problem usually happens on accident as a
  # result of refactoring.
  # 
  # Note that the `prefer-template` rule enforces the use of template literals
  # over string concatenation when embedding expressions. This rule addresses
  # situations that don't involve embedding expressions.
  no-useless-concat: error

  # Never escape non-special characters in strings, template literals, and
  # regular expressions; it's pointless. This problem usually happens on
  # accident due to escaping the wrong character.
  no-useless-escape: error

  # Never use the `void` operator; it reduces accessibility because it's not
  # widely understood that `void` always returns `undefined`. Instead, reference
  # `undefined` directly. Better yet, use `null` instead of `undefined` whenever
  # possible; it improves correctness, debuggability, expressiveness, and
  # accessibility due to the ambiguity of `undefined` (which can mean either
  # "undeclared", "declared but unassigned", or "declared and explicitly
  # assigned to `undefined`"). 
  #
  # Note that some guides recommend using `void` instead of referencing
  # `undefined` directly because `undefined` can be redefined or shadowed, thus
  # opening the door for unexpected behavior. But starting with ES5, the global
  # `undefined` can't be redefined, and the `no-shadow-restricted-names` rule
  # disallows shadowing `undefined`.
  no-void: error

  # Feel free to add inline reminders using `// TODO:` comments; it improves
  # maintainability, and is more effective than keeping a list of issues in a
  # separate document.
  #
  # This rule is set to `warn` so that it provides reminders about outstanding
  # issues but doesn't cause the build to fail.
  no-warning-comments: warn

  # Never use the `with` statement; it's disallowed in strict mode, and it
  # reduces correctness, expressiveness, and accessibility because it's a highly
  # error-prone and misunderstood feature.
  no-with: error

  # When using `parseInt`, always provide the radix. Otherwise, it reduces
  # correctness because the engine autodetects which type of number it should
  # return based on the first argument, thus opening the door to mistakes. It
  # also reduces expressiveness, especially when the first argument is a
  # variable instead of a string, since it might not be clear which type of
  # number is expected to be returned.
  #
  # This rule is still worth it even though in ES5 the `parseInt` function no
  # longer auto-detects octals, so the risk of accidentally ending up with the
  # wrong radix via auto-detection due to an errant leading zero is reduced. It
  # can still auto-detect hexadecimal values (starting with `0x`).
  radix:
    - error
    - always

  # Always put `var` declarations at the top of the function or program.
  # Otherwise, it reduces accessibility because it's not widely understood that
  # variables defined via `var` are hoisted and aren't block-scoped, and reduces
  # correctness because it's easy to forget those concepts and make a mistake.
  # Better yet, use `let` and `const` instead of `var`; they're both
  # block-scoped.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  vars-on-top: error

  # Always wrap immediately-invoked function expressions (even when invoked via
  # `.call` or `.apply`) in parentheses; it slightly improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  wrap-iife:
    - error
    - inside
    - functionPrototypeMethods: true

  # Never use the yoda style (e.g., `if (5 === x)`); it reduces consistency
  # because it's not widely used in other projects, and reduces accessibility
  # because it acts contrary to the natural flow of thought. Also, the
  # `no-cond-assign` rule already protects against the accidental assignment of
  # variables in conditionals, overlapping any benefit of the yoda style in
  # terms of correctness.
  yoda:
    - error
    - never

  ###############
  # Strict Mode #
  ###############

  # Always enable strict mode at the global level; it improves correctness by
  # preventing common mistakes. In Node.js code, put `"use strict";` at the top
  # of each module file. Once ES6 modules are implemented, or when transpiling
  # via babel, disable this rule in the local config file; strict mode is either
  # implied or enabled automatically.
  strict:
    - error
    - global

  #############
  # Variables #
  #############

  # Always assign variables at the same time that they're declared; it improves
  # correctness, and improves expressiveness by removing doubt; did the
  # developer forget to assign an initial value? If declaring a variable before
  # its value has been determined, then assign it to `null` instead of
  # `undefined`; it improves correctness, debuggability, expressiveness, and
  # accessibility due to the ambiguity of `undefined` (which can mean either
  # "undeclared", "declared but unassigned", or "declared and explicitly
  # assigned to `undefined`").
  init-declarations:
    - error
    - always

  # This rule is disabled because it protects against a bug that's only present
  # in IE8 and earlier.
  no-catch-shadow: off

  # Never use `delete` on a variable; it only works on object properties. If
  # resetting a variable, then reassign it to `null`.
  #
  # Note that the `prefer-reflect` rule enforces the use of
  # `Reflect.deleteProperty` over `delete`. This rule is only enabled in case
  # the `prefer-reflect` rule is disabled.
  no-delete-var: error

  # Never declare a variable with the same name as a label, or vice-versa; it
  # reduces debuggability and expressiveness due to the resulting ambiguity.
  no-label-var: error

  # This rule is disabled. It may be enabled in the future if there are global
  # variables that are deemed important enough to disallow by default.
  no-restricted-globals: off

  # Never shadow a global object or identifier such as `undefined`; it reduces
  # correctness, and reduces consistency because it defies the expectation that
  # global objects and identifiers can be referenced anywhere by name.
  no-shadow-restricted-names: error

  # Never declare a variable in an inner scope with the same name as an existing
  # variable in an outer scope (including global variables); it reduces
  # correctness, and reduces expressiveness by creating doubt: did the developer
  # accidentally declare a variable with the same name instead of referencing
  # the existing one in the outer scope?
  #
  # The `hoist` option is set to `all` because although it's not technically
  # shadowing when the variable in the outer scope is declared after the inner
  # function, and thus the chance of closure-related mistakes is lowered, it
  # still reduces expressiveness without adding value.
  no-shadow:
    - error
    - builtinGlobals: true
      hoist: all
 
  # When initializing a variable to `undefined`, always do so explicitly instead
  # of implicitly; it improves correctness, and improves expressiveness by
  # removing doubt: did the developer forget to assign an initial value? Better
  # yet, initialize the variable to `null` instead of `undefined` whenever
  # possible; it improves correctness, debuggability, expressiveness, and
  # accessibility due to the ambiguity of `undefined` (which can mean either
  # "undeclared", "declared but unassigned", or "declared and explicitly
  # assigned to `undefined`").
  #
  # This rule is disabled because it promotes implicitly initializing a variable
  # to `undefined` instead of doing so explicitly. The argument in favor of
  # implicitness is that `undefined` can be redefined or shadowed, thus reducing
  # correctness. But starting with ES5, the global `undefined` can't be
  # redefined, and the `no-shadow-restricted-names` rule disallows shadowing
  # `undefined`.
  #
  # Note that the `init-declarations` rule disallows declaring a variable
  # without explicitly initializing it at the same time.
  no-undef-init: off

  # Never reference a variable that hasn't been declared, not even when using
  # the `typeof` operator; it reduces correctness, and reduces expressiveness
  # by creating doubt: did the developer mistype the variable name? If the
  # variable is a global that's not recognized by ESLint for the specified
  # environment, then add the variable to the `globals` section of the local
  # config file.
  no-undef:
    - error
    - typeof: true

  # When referencing `undefined`, always do so explicitly instead of implicitly;
  # it improves correctness and expressiveness, and improves accessibility
  # because it's not widely understood that `void` always returns `undefined`.
  # Better yet, use `null` instead of `undefined` whenever possible; it improves
  # correctness, debuggability, expressiveness, and accessibility due to the
  # ambiguity of `undefined` (which can mean either "undeclared", "declared but
  # unassigned", or "declared and explicitly assigned to `undefined`").
  #
  # This rule is disabled because it promotes referencing `undefined` implicitly
  # instead of explicitly. The argument in favor of implicitness is that
  # `undefined` can be redefined or shadowed, thus reducing correctness. But
  # starting with ES5, the global `undefined` can't be redefined, and the
  # `no-shadow-restricted-names` rule disallows shadowing `undefined`.
  # 
  # Note that the `no-void` rule disallows the use of `void`, and the
  # `init-declarations` rule disallows declaring a variable without explicitly
  # initializing it at the same time.
  no-undefined: off

  # Always use every variable and `catch`-block exception argument at least
  # once. Otherwise, it's pointless to declare them. For the same reason, use
  # every function argument at least once unless writing a callback with a
  # predefined argument order when the first argument isn't needed but one or
  # more subsequent ones are, in which case disable this rule via an inline
  # comment. This problem usually happens on accident as a result of
  # refactoring.
  no-unused-vars:
    - error
    - vars: all
      args: all
      caughtErrors: all

  # Never reference a variable, function, or class before defining it; it
  # reduces correctness, and reduces accessibility because variable hoisting
  # isn't widely understood. In the case of ES6 bindings such as `let`, it
  # throws a `ReferenceError` when executed.
  no-use-before-define:
    - error
    - functions: true
      classes: true

  ########################
  # Node.js and CommonJS #
  ########################

  # When invoking a callback function but not returning immediately thereafter,
  # always express into by disabling this rule via an inline comment; it
  # improves expressiveness by removing doubt: did the developer forget to add
  # a `return` statement after invoking the callback?
  #
  # Note that this rule only applies to callback functions assigned to function
  # arguments named "callback", "cb", and "next".
  callback-return: error

  # Feel free to conditionally require modules. This rule is disabled because
  # it's not a problem.
  global-require: off

  # When defining a function with `err` as the first argument, always add error
  # handling logic. Otherwise, it reduces correctness because errors go
  # unhandled. This problem usually happens by accident.
  handle-callback-err: error

  # Never mix require statements with other variable declarations; it reduces
  # elegance.
  no-mixed-requires:
    - error
    - grouping: false
      allowCall: true

  # Never use `new` in conjunction with a `require` statement; it reduces
  # correctness, and reduces accessibility because it's not widely understood
  # that it only works properly if parentheses are added around the require
  # statement (e.g., `const dog = new (require("./dog"));`). Instead, assign the
  # result of the `require` statement to a variable, and then use `new` in
  # conjunction with the variable.
  no-new-require: error

  # When combining strings containing parts of a directory or file path, never
  # use string concatenation; it reduces correctness because different platforms
  # use different path separators, and because it's easy to accidentally add
  # double separators. Instead, use Node's `path.join` or `path.resolve`.
  no-path-concat: error

  # When using `process.env`, always create a module wrapper around it, and
  # disable this rule at the top of the module file. Otherwise, it reduces
  # testability because it's more difficult to create a test double of a global
  # than a module.
  no-process-env: error

  # Never use `process.exit`; it reduces testability because it's difficult to
  # test a code path that immediately terminates the application. Instead, throw
  # an error.
  no-process-exit: error

  # This rule is disabled. It may be enabled in the future if there are modules
  # that are deemed important enough to disallow by default.
  no-restricted-modules: off

  # When using a synchronous I/O function, always express intent by disabling
  # this rule via an inline comment. Otherwise, it reduces performance, and
  # reduces expressiveness by creating doubt: did the developer accidentally use
  # a synchronous I/O function instead of its asynchronous counterpart? If a
  # project exclusively uses synchronous I/O, then disable this rule in the
  # local config file.
  no-sync: error

  ####################
  # Stylistic Issues #
  ####################

  # Never add spaces between array brackets and the tokens inside; it reduces
  # elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  array-bracket-spacing:
    - error
    - never
    - singleValue: false
      objectsInArrays: false
      arraysInArrays: false

  # Always add a space between each brace and the code inside when writing a
  # single-line block; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  block-spacing:
    - error
    - always

  # Always follow the one true brace style by putting the opening brace of a
  # block on the same line as its corresponding statement or declaration; it
  # improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  brace-style:
    - error
    - 1tbs
    - allowSingleLine: true

  # Always use camelcase instead of underscores when naming non-constants; it
  # improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  camelcase:
    - error
    - properties: always

  # Always include a comma at the end of the last item in a multiline list; it
  # improves maintainability by producing cleaner diffs when an item is added to
  # or removed from the end.
  comma-dangle:
    - error
    - arrays: always-multiline
      exports: always-multiline
      functions: always-multiline
      imports: always-multiline
      objects: always-multiline

  # Always add a space after commas instead of before; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  comma-spacing:
    - error
    - after: true
      before: false

  # Always place commas after (instead of before) each item in a multiline list;
  # it improves maintainability by producing cleaner diffs when an item is added
  # to or removed from the beginning.
  comma-style:
    - error
    - last

  # Never add spaces between computed property brackets and the values inside;
  # it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  computed-property-spacing:
    - error
    - never

  # Always name a variable `self` when it's being used to capture `this`; it
  # improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  consistent-this:
    - error
    - self

  # Always add a trailing newline at the end of files; it makes it easier to
  # append files as well as output files to the terminal without messing up the
  # shell prompt.
  eol-last:
    - error
    - always

  # Never add a space between a function invocation and the opening parenthesis
  # of the argument list; it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  func-call-spacing:
    - error
    - never

  # When defining a function expression (other than `module.exports`) that's
  # automatically given a name in ES6 based on context, never manually give it a
  # different name; it reduces consistency. Instead, don't manually give it a
  # name at all; the one assigned automatically is sufficient.
  #
  # Note that this rule only disallows manually giving a function expression a
  # different name than the one that's automatically given in ES6 based on
  # context; it doesn't disallow manually giving it the same name.
  func-name-matching:
    - error
    - includeCommonJSModuleExports: false

  # Always manually give a name to a function expression when it's not
  # automatically given one in ES6 based on context; it improves debuggability
  # by producing more informative stack traces. Also, never manually give a name
  # to a function expression when it's automatically given one in ES6 based on
  # context; it's pointless.
  #
  # Note that this rule is disabled because it doesn't currently support the
  # desired policy. If https://github.com/eslint/eslint/pull/7244 is merged,
  # then this rule will be enabled with the `uninferred` option. Also note that
  # context-based automatic naming of functions is new to ES6.
  func-names: off

  # Always use function expressions (instead of function declarations or arrow
  # functions); compared to function declarations, they improve correctness and
  # expressiveness by allowing either `let` or `const` to be used depending on
  # whether or not the variable is later reassigned, and compared to arrow
  # functions they improve debuggability by producing more informative stack
  # traces (when a name is manually or automatically given).
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions.
  func-style:
    - error
    - expression
    - allowArrowFunctions: false

  # This rule is disabled. It may be enabled in the future if there are
  # identifiers that are deemed important enough to disallow by default.
  id-blacklist: off

  # Feel free to use identifiers of any length; even `i` is expressive enough in
  # many situations where iteration is obvious. This rule is disabled because
  # it's not a problem.
  id-length: off

  # This rule is disabled because it doesn't add enough value over other rules
  # such as `camelcase`.
  id-match: off

  # Always use two-space indentation; tabs reduce maintainability by causing
  # alignment issues across development environments. The number of spaces is
  # personal preference.
  indent:
    - error
    - 2
    - SwitchCase: 1
      VariableDeclarator: 1
      outerIIFEBody: 1
      MemberExpression: 1
      FunctionDeclaration:
        parameters: 1
        body: 1
      FunctionExpression:
        parameters: 1
        body: 1

  # This rule is disabled due to lack of jsx usage. It may be enabled in the
  # future.
  jsx-quotes: off

  # When defining properties in an object literal, never add any spaces before
  # the colon, and always add exactly one space after the colon; it improves
  # maintainability because otherwise whenever a new property is added to the
  # object with a longer name than the existing properties, all properties in
  # the object must be realigned, resulting in noisy diffs.
  #
  # Note that the `no-multi-spaces` rule also disallows the use of multiple
  # spaces.
  key-spacing:
    - error
    - afterColon: true
      beforeColon: false
      mode: strict

  # Always add a single space before and after keywords such as `if` and `else`;
  # it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  keyword-spacing:
    - error
    - after: true
      before: true

  # Feel free to add comments anywhere. This rule is disabled because it's not a
  # problem.
  line-comment-position: off

  # Always use Unix line endings; Unix is a more common development environment
  # for Node.js than Windows.
  linebreak-style:
    - error
    - unix

  # Feel free to add comments anywhere. This rule is disabled because it's not a
  # problem.
  lines-around-comment: off

  # Always add empty lines before and after directives such as `"use strict";`;
  # it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  lines-around-directive:
    - error
    - always

  # This rule is disabled due to personal preference.
  max-depth: off

  # Always limit lines to 80 characters; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  max-len:
    - error
    - code: 80
      tabWidth: 2
      comments: 80
      ignoreComments: false
      ignoreTrailingComments: false
      ignoreUrls: false
      ignoreStrings: false
      ignoreTemplateLiterals: false

  # This rule is disabled due to personal preference.
  max-lines: off

  # This rule is disabled due to personal preference.
  max-nested-callbacks: off

  # This rule is disabled due to personal preference.
  max-params: off

  # This rule is disabled due to personal preference.
  max-statements: off

  # This rule is disabled due to personal preference.
  max-statements-per-line: off

  # This rule is disabled due to personal preference. Note that the `no-ternary`
  # rule disallows the ternary operator.
  multiline-ternary: off

  # Only use `new` in conjunction with functions that begin with an uppercase,
  # and only invoke functions that begin with an uppercase by using `new`; it
  # improves consistency because there's an expectation that functions that
  # start with a capital letter are constructors, and ones that don't aren't. If
  # using a 3rd-party library that violates this expectation, then use the
  # `newIsCapExceptions` or `capIsNewExceptions` option to add an exception to
  # this rule in the local config file.
  new-cap:
    - error
    - capIsNew: true
      newIsCap: true
      properties: true

  # Always add parentheses to the end of the constructor when invoking it with
  # `new`, even if not providing any arguments; it improves consistency.
  new-parens: error

  # Always add a new line after variable declarations; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  newline-after-var:
    - error
    - always

  # Always add a new line before `return` statements in multiline blocks; it
  # improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  newline-before-return: error

  # When chaining multiple method calls, consider putting each one on its own
  # line, especially when passing numerous and/or complex arguments; it improves
  # maintainability by producing cleaner diffs when one of the calls is
  # modified, and sometimes improves elegance.
  #
  # This rule is disabled because in many situations putting each method call on
  # its own line drastically reduces elegance without sufficiently improving
  # maintainability. The decision to add a new line is situational and
  # subjective.
  newline-per-chained-call: off

  # Only use the `Array` constructor when a sparse array is needed, in which
  # case express intent by disabling this rule via an inline comment. Otherwise,
  # it reduces correctness, and reduces accessibility because it's not widely
  # understood that providing a single argument creates a sparse array of the
  # given size whereas providing multiple arguments creates an array with the
  # given elements, and reduces expressiveness by creating doubt: did the
  # developer accidentally create a sparse array instead of an array with a
  # single element? Instead, use array literal notation whenever possible.
  no-array-constructor: error

  # Don't use bitwise operators (e.g., `&` and `|`) unless necessary for a
  # reason other than elegance, in which case express intent by disabling this
  # rule via an inline comment. Otherwise, it reduces correctness, and reduces
  # accessibility because bitwise operators aren't widely understood, and
  # reduces expressiveness by creating doubt: did the developer accidentally
  # type `&` instead of `&&`?
  no-bitwise:
    - error
    - int32Hint: false

  # Feel free to use the `continue` statement. This rule is disabled due to
  # personal preference.
  no-continue: off

  # Feel free to add comments anywhere. This rule is disabled due to personal
  # preference.
  no-inline-comments: off

  # Never nest a lone `if` inside of an `else`'s execution block; it reduces
  # elegance. Instead, use `else if`.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-lonely-if: error

  # When combining binary expressions of varying precedence, always add extra
  # parentheses; it increases correctness, and increases expressiveness by
  # removing doubt: did the developer fully understand order of operations?
  no-mixed-operators:
    - error
    - allowSamePrecedence: true

  # Never mix tabs and spaces; it reduces maintainability by causing alignment
  # issues across development environments. Instead, always use spaces.
  #
  # Note that the `no-tabs` rule disallows the use of tabs.
  no-mixed-spaces-and-tabs: error

  # Never put more than one empty line in a row; it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-multiple-empty-lines:
    - error
    - max: 1

  # Never negate conditions when writing an `if`/`else` statement or a ternary
  # expression; it reduces elegance. Instead, invert the condition.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-negated-condition: error

  # Never use a nested ternary expression; it reduces correctness and
  # expressiveness, and reduces accessibility because the ternary operator isn't
  # widely understood, especially when nested. Instead, use an expressive
  # alternative, such as nested `if`/`else` statements.
  #
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  no-nested-ternary: error

  # Never create an object using `new Object();`; it reduces elegance. Instead,
  # use an object literal.
  no-new-object: error

  # Don't use unary operators such as `++` unless writing the final expression
  # in a `for` statement; they reduce correctness and expressiveness, and reduce
  # accessibility because it's not widely understood how white space and
  # automatic semicolon injection can change the meaning of expressions that
  # contain unary operators. Instead, use `+=`.
  no-plusplus:
    - error
    - allowForLoopAfterthoughts: true

  # Never use an arrow function; it reduces debuggability by producing a less
  # informative stack trace. Instead, use a function expression, and manually
  # give it a name when it's not automatically given one in ES6 based on
  # context.
  #
  # Note that the `func-style` rule enforces the use of function expressions
  # over function declarations and arrow functions.
  no-restricted-syntax:
    - error
    - ArrowFunctionExpression

  # Never use tabs; they reduce maintainability by causing alignment issues
  # across development environments. Instead, always use spaces.
  no-tabs: error

  # Never use the ternary operator; it reduces correctness and expressiveness,
  # and reduces accessibility because it's not widely understood. Instead, use
  # an expressive alternative, such as `if`/`else`.
  no-ternary: error

  # Never add extra spaces to the end of a line; it's pointless. This problem
  # usually happens on accident.
  no-trailing-spaces:
    - error
    - skipBlankLines: false

  # Feel free to use dangling underscores in identifiers. This rule is disabled
  # because it's not a problem.
  no-underscore-dangle: off

  # Never use a ternary expression in a situation that has an easier alternative
  # (e.g., `let foo = bar ? bar : 1;` is better expressed as
  # `let foo = bar || 1;`); it reduces correctness and expressiveness, and
  # reduces accessibility because the ternary operator isn't widely understood.
  # 
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  no-unneeded-ternary:
    - error
    - defaultAssignment: false

  # Never add whitespace around the dot or before the bracket of object
  # properties (except when indenting on a new line); it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  no-whitespace-before-property: error

  # When defining an object literal or destructuring assignment that contains
  # line breaks, always add a line break after the opening curly and before the
  # closing curly; it improves maintainability by producing cleaner diffs when a
  # property is added to or removed from the beginning or end.
  object-curly-newline:
    - error
    - multiline: true

  # Never add spaces between object literal and destructuring assignment braces,
  # and the tokens inside; it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  object-curly-spacing:
    - error 
    - never

  # When defining a multiline object literal or destructuring assignment, always
  # put each property on a separate line; it improves maintainability by
  # producing cleaner diffs when a property is modified, added, or removed.
  object-property-newline:
    - error
    - allowMultiplePropertiesPerLine: true

  # When declaring a group of variables, always use a separate declaration for
  # each variable; it improves maintainability by producing cleaner diffs when a
  # variable is added to or removed from the beginning or end of the group.
  one-var:
    - error
    - never

  # When declaring a group of variables, always put each declaration on a
  # separate line; it improves maintainability by producing cleaner diffs when a
  # declaration is modified, added, or removed.
  #
  # Note that the `one-var` rule enforces a separate declaration to be made for
  # each variable, whereas this rule only addresses multi-variable declarations.
  # Therefore, this rule is only enabled in case the `one-var` rule is disabled.
  one-var-declaration-per-line:
    - error
    - always

  # Always use shorthand operators such as `+=` for simple math operations; it
  # improves elegance.
  operator-assignment:
    - error
    - always

  # Always place the operator at the end of the current line instead of the
  # start of the next line when breaking an expression across multiple lines;
  # it improves expressiveness by signaling that the expression continues on the
  # next line.
  operator-linebreak:
    - error
    - after

  # Never add empty lines as padding inside of blocks; it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency.
  padded-blocks:
    - error
    - never

  # When defining an object literal, always put double quotes around property
  # names; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  # Note that the `quotes` rule enforces double quotes over single quotes.
  quote-props:
    - error
    - always

  # When defining a string, always use double quotes or backticks (instead of
  # single quotes); it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  quotes:
    - error
    - double
    - avoidEscape: false
      allowTemplateLiterals: true

  # This rule is disabled due to lack of jsdoc usage. It may be enabled in the
  # future.
  require-jsdoc: off

  # Never add a space before a semicolon; it reduces elegance. Also, always add
  # a space after a semicolon when it's not at the end of a line; it improves
  # elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  semi-spacing:
    - error
    - after: true
      before: false
 
  # Always add a semicolon at the end of each statement (except when the full
  # statement is inside braces on a single line); it improves correctness by
  # avoiding unexpected behavior due to automatic semicolon insertion, and
  # improves accessibility because it's not widely understood how automatic
  # semicolor insertion works, and improves expressiveness by removing doubt:
  # did the developer understand automatic semicolon insertion when they left
  # off a semicolon at the end?
  semi:
    - error
    - always
    - omitLastInOneLineBlock: true

  # Feel free to sort object properties in whichever order that makes sense.
  # This rule is disabled because it's not a problem.
  sort-keys: off

  # Feel free to sort variable declarations in whichever order that makes sense.
  # This rule is disabled because it's not a problem.
  sort-vars: off

  # Always add a space before a block; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  space-before-blocks:
    - error
    - always

  # Always add a space before the opening parenthesis in a function definition;
  # it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  space-before-function-paren:
    - error
    - anonymous: always
      asyncArrow: always
      named: always

  # Never add spaces between parentheses and the contents inside; it reduces
  # elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  space-in-parens:
    - error
    - never

  # Always add spaces around operators such as `+`; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  space-infix-ops:
    - error
    - int32Hint: false

  # Always add spaces after unary word operators such as `new` and `delete`;
  # they improve elegance. Also, never add unnecessary spaces around unary
  # non-word operators such as `++`; they reduce elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  space-unary-ops:
    - error
    - words: true
      nonwords: false

  # Always add a space after the opening `//` or `/*` in a comment, and before
  # the closing `*/` when it's on the same line; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  spaced-comment:
    - error
    - always
    - block:
        balanced: true

  # Never specify whether or not a code unit is big or little endian; it's
  # pointless when using UTF-8 encoding.
  unicode-bom:
    - error
    - never

  # Never wrap regex literals in parentheses.
  #
  # This rule is disabled because of personal preference.
  wrap-regex: off

  ################
  # ECMAScript 6 #
  ################

  # Only use arrow functions to return single line expressions. If braces are
  # needed, then use a function expression instead; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  # Note that the `no-restricted-syntax` rule  disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-body-style:
    - error
    - never

  # Only add parentheses around an arrow function's arguments when there's more
  # than one. Otherwise, it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-parens:
    - error
    - as-needed
    - requireForBlockBody: false

  # Always add a space before and after the `=>` when defining an arrow
  # function; it improves elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-spacing:
    - error
    - after: true
      before: true

  # Always call `super()` from within the constructors of derived classes.
  # Otherwise, it throws an error upon execution.
  constructor-super: error

  # When defining a generator function, always add a space after the star, and
  # never add a space before the start. Otherwise, it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  generator-star-spacing:
    - error
    - after: true
      before: false

  # Never reassign a class; it reduces correctness and debuggability, and
  # reduces consistency by defying the expectation that a class instance can
  # always be created by name once the class is defined.
  no-class-assign: error

  # Never define an arrow function in a place where it can be confused with a
  # `>=` comparison operator; it reduces correctness, and reduces expressiveness
  # by creating doubt: did the developer accidentally define an arrow function
  # intsead of performing an equality comparison? Instead, use a function
  # expression.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  no-confusing-arrow:
    - error
    - allowParens: false

  # Never reassign a variable defined via `const`; it'll throw an error upon
  # execution. Instead, define the variable via `let`. This problem usually
  # happens on accident.
  no-const-assign: error

  # Never define a class that has multiple properties with the same name;
  # it's pointless because the last occurrence shadows the one(s) before it.
  # This problem usually happens on accident.
  no-dupe-class-members: error

  # Always use a single `import` statement per module unless exporting from an
  # imported module, in which case the export should occur in a separate
  # statement. Otherwise, it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  no-duplicate-imports:
    - error
    - includeExports: false

  # Never use `new` when creating a `Symbol`; it's designed to be called as a
  # function.
  no-new-symbol: error

  # This rule is disabled. It may be enabled in the future if there are modules
  # that are deemed important enough to disallow by default.
  no-restricted-imports: off

  # Never reference `this` before `super` in the constructor of a derived class;
  # it throws a `ReferenceError`.
  no-this-before-super: error

  # Never use a computed property when it could be expressed as a non-computed
  # property; it's pointless.
  no-useless-computed-key: error

  # When defining a class, always define a constructor, even if it's identical
  # to the default constructor. Otherwise, it reduces correctness, and reduces
  # expressiveness by creating doubt: did the developer forget to define a
  # constructor?
  #
  # This rule is disabled because it promotes an unexpressive style.
  no-useless-constructor: off

  # When destructuring, importing, or exporting, never rename a reference
  # without actually changing the name; it's pointless.
  no-useless-rename:
    - error
    - ignoreDestructuring: false
      ignoreExport: false
      ignoreImport: false

  # Never use `var` to declare a variable; it reduces correctness, and reduces
  # accessibility because variable hoisting and block scope aren't widely
  # understood, and reduces expressiveness because it doesn't convey whether or
  # not the value is intended to be reassigned. Instead, use `let` or `const`.
  no-var: error

  # Always use object shorthand syntax when possible; it improves elegance.
  object-shorthand:
    - error
    - always
    - avoidQuotes: false
      ignoreConstructors: false

  # Never use arrow functions; they reduce debuggability by producing less
  # informative stack traces. Instead, use function expressions with a name
  # manually or automatically given.
  #
  # This rule is disabled because it promotes a less debuggable style. Note that
  # the `no-restricted-syntax` rule disallows the use of arrow functions. This
  # rule is only enabled in case the `no-restricted-syntax` rule is disabled.
  prefer-arrow-callback: off

  # Never use `let` unless the variable is reassigned; it reduces correctness
  # because it opens the door to accidental reassignment, and reduces
  # expressiveness because it doesn't convey whether or not the variable is
  # intended to be reassigned. Instead, use `const`.
  prefer-const:
    - error
    - destructuring: any
      ignoreReadBeforeAssign: false

  # Feel free to use `parseInt` with a radix value of `2`, `8`, or `16`.
  #
  # This rule is disabled because ES6 binary, octal, and hexademical literals
  # don't add sufficient expressiveness over `parseInt`.
  prefer-numeric-literals: off

  # Always prefer ES6 `Reflect` methods over their pre-ES6 alternatives; they
  # more closely represent the inner workings of JavaScript without sacrificing
  # readability.
  prefer-reflect: error

  # When converting a list of arguments into a single variable, always use rest
  # parameters (e.g., `...`) instead of `arguments`; they improve correctness,
  # and improve accessibility because it's not widely understood that
  # `arguments` isn't an actual array, and improve elegance by allowing a subset
  # of arguments to be captured.
  prefer-rest-params: error

  # When passing a list of arguments in array form to a function, always invoke
  # the function normally and use the spread operator (e.g., `...vals`) instead
  # of invoking the function via `.apply`; it improves elegance by allowing a
  # subset of the arguments to be passed via an array.
  prefer-spread: error

  # Always use template literals instead of string concatenation when embedding
  # expressions into a string; it improves elegance.
  prefer-template: error

  # Never define a generator function that doesn't call `yield`; it's pointless.
  # Instead, use a regular function.
  require-yield: error

  # Never add a space between the spread operator and its expression; it reduces
  # elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  rest-spread-spacing:
    - error
    - never

  # Feel free to sort imports in whichever order that makes sense. This rule is
  # disabled because it's not a problem.
  sort-imports: error

  # Always provide a description when defining a `Symbol`; it improves
  # debuggability by producing more informative stack traces.
  symbol-description: error

  # Never add spaces between template literal braces and the expression inside;
  # they reduce elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  template-curly-spacing:
    - error
    - never

  # When using the `yield` statement, always add a space after the star, and
  # never add a space before the star. Otherwise, it reduces elegance.
  #
  # This rule is highly subjective. Its main value is enforcing consistency. 
  yield-star-spacing:
    - error
    - after: true
      before: false

parserOptions:
  ecmaVersion: 2017
env:
  es6: true
rules:
  ###################
  # Possible Errors #
  ###################

  # Don't put an assignment expression inside of a conditional unless necessary,
  # in which case express intent by disabling this rule via an inline comment.
  # Otherwise, there's doubt about whether or not it's intentional; it's common
  # to accidentally type `=` instead of `===`.
  #
  # The `always` option is set instead of the default `except-parens` option
  # because wrapping the assignment in an extra set of parenthesis isn't
  # sufficient for expressing intent.
  no-cond-assign:
    - error
    - always

  # Don't release code containing a `console` statement unless in a development
  # environment, in which case set this rule to `warn` instead of `error` in the
  # local config file so that the build doesn't fail but reminders are still
  # provided.
  no-console: error

  # Don't use a constant expression as a conditional unless necessary, in which
  # case express intent by disabling this rule via an inline comment, or assign
  # the constant to a variable with an explanatory name. Otherwise, there's
  # doubt about whether or not it's intentional; it's common to make a mistake
  # in logic that results in an infinite loop or an `if` statement that always
  # has the same result.
  no-constant-condition:
    - error
    - checkLoops: true

  # Feel free to use control characters in regular expressions.
  #
  # This rule is disabled because it doesn't add enough value. There are
  # legitimate uses for control characters, especially in server-side
  # programming. They're rarely used on accident, and even when they are, the
  # consequences usually aren't severe.
  no-control-regex: off

  # Don't release code containing a `debugger` statement unless in a development
  # environment, in which case set this rule to `warn` instead of `error` in the
  # local config file so that the build doesn't fail but reminders are still
  # provided.
  no-debugger: error

  # Never define a function that has multiple arguments with the same name; the
  # last occurrence shadows the one(s) before it.
  no-dupe-args: error

  # Never define an object literal that has multiple properties with the same
  # name; the last occurrence shadows the one(s) before it.
  no-dupe-keys: error

  # Never define a `switch` statement that has multiple cases with the same
  # clause; the first occurrence is the only one that'll ever be matched.
  no-duplicate-case: error

  # Don't write an empty block of code unless necessary, in which case express
  # intent by adding a comment inside. Otherwise, there's doubt about whether or
  # not it's intentional; it's common to accidentally be left with an empty
  # block of code after refactoring.
  no-empty:
    - error
    - allowEmptyCatch: false

  # Never include empty brackets in a regular expression; an empty character set
  # doesn't match anything. If needing to include "[]" as part of the pattern,
  # then escape each bracket.
  no-empty-character-class: error

  # Never reassign the exception parameter in a `catch` block; there's an
  # expectation that the exception parameter will always reference the caught
  # error. Instead, assign the exception to a separate variable that can later
  # be reassigned as necessary.
  no-ex-assign: error

  # Never cast a variable to a boolean as part of a test condition; it's done
  # automatically by the engine.
  no-extra-boolean-cast: error

  # Always add extra parentheses when combining binary expressions of varying
  # precedence; it makes the logic easier to understand, and it removes doubt
  # about whether or not the expressions were written with a correct
  # understanding of the order of operations. Never add extra parentheses in
  # other situations; it reduces readability without adding value.
  #
  # Note that the `no-mixed-operators` rule is the one that enforces the use of
  # extra parentheses when combining binary expressions of varying precedence.
  # This rule merely gets out of the way of the `no-mixed-operators` rule while
  # also preventing extra parentheses in other situations.
  no-extra-parens:
    - error
    - all
    - conditionalAssign: false
      nestedBinaryExpressions: true
      returnAssign: false

  # Never put semicolons anywhere that not even automatic semicolon insertion
  # would add one; it reduces readability without adding value. It's a common
  # accident to type `;;` instead of `;`, or to add a `;` after the closing
  # brace of a function declaration.
  no-extra-semi: error

  # Never reassign a function declaration; there's an expectation that a
  # function defined in this way will never be reassigned. Instead, assign a
  # function expression to a variable that can later be reassigned as necessary.
  no-func-assign: error

  # Feel free to use function declarations in nested blocks; starting with ES6,
  # function declarations are appropriately block-scoped.
  # 
  # This rule is disabled because it only applies to pre-ES5 environments. Note
  # that the `no-var` rule enforces the use of  `let` and `const` over `var`.
  no-inner-declarations: off

  # Never put an invalid regular expression inside of a `RegExp` constructor; it
  # throws a `SyntaxError` when executed.
  no-invalid-regexp: error

  # Don't use non-standard whitespace characters unless necessary, in which case
  # express intent by disabling this rule via an inline comment. Otherwise, it
  # can lead to unexpected behavior during string operations, and there's doubt
  # about whether or not it's intentional; it's a common accident to copy and
  # paste code from the web that contains non-standard whitespace characters.
  no-irregular-whitespace:
    - error
    - skipStrings: false
      skipComments: false
      skipRegExps: false
      skipTemplates: false

  # Never invoke non-function global objects such as `Math` or `JSON` as if
  # they're functions; it throws a `TypeError` when executed.
  no-obj-calls: error

  # Never directly invoke an `Object.prototype` method on an object; it's
  # possible for such methods to be shadowed, or for an object to not even have
  # `Object.prototype` in its prototype chain. Instead, use `call`, or wrap them
  # in stand-alone helper functions.
  no-prototype-builtins: error

  # Never chain multiple spaces together in a regex; it makes it difficult to
  # count the number of spaces, and it creates doubt about whether or not the
  # current number of spaces is intentional; it's a common accident to type `  `
  # instead of ` `. Instead, use a single space followed by `{n}` where `n` is
  # the number of spaces.
  no-regex-spaces: error

  # Don't create a sparse array unless necessary, in which case express intent
  # by disabling this rule via an inline comment. Otherwise, there's doubt about
  # whether or not it's intentional; it's a common accident to type `,,` instead
  # of `,`.
  no-sparse-arrays: error

  # Don't put a template literal placeholder such as `${var}` inside of a
  # single- or double-quoted string unless necessary, in which case express
  # intent by disabling this rule via an inline comment. Otherwise, there's
  # doubt about whether or not it's intentional; it's a common accident to use
  # single or double quotes instead of backticks.
  no-template-curly-in-string: error

  # Never split an expression across multiple lines in such a way that the
  # newline looks like it's ending the statement when it's not; it creates
  # confusion without adding value.
  no-unexpected-multiline: error

  # Never put code after an unconditional exit statement; it's never executed.
  no-unreachable: error

  # Never put a control flow statement such as `return` inside of a `finally`
  # block; it leads to unexpected behavior because it's not commonly understood
  # that control flow statements inside of a `finally` block take priority over
  # control flow statement inside of a `try` or `catch` block.
  no-unsafe-finally: error

  # Never negate the left operand when using `in` or `instanceof`; it leads to
  # unexpected behavior, and it creates doubt about whether or not it's
  # intentional; it's common to forget that only the left operand is negated,
  # not the full expression. Instead, either wrap the full expression in
  # parentheses after the `!`, or refactor so that such ambiguity is avoided.
  no-unsafe-negation: error

  # Never compare a value to `NaN`; it leads to unexpected behavior due to `NaN`
  # not being equal to itself. Instead, use `isNaN` or `Number.isNaN`.
  use-isnan: error

  # This rule is disabled due to lack of jsdoc usage. It may be enabled in the
  # future.
  valid-jsdoc: off

  # Never compare a `typeof` expression to any string literal other than one of
  # the valid types; it always fails. The `requireStringLiterals` option is set
  # to `false` because comparing a `typeof` expression to a variable isn't a
  # problem.
  valid-typeof:
    - error
    - requireStringLiterals: false

  ##################
  # Best Practices #
  ##################

  # Never define a setter via `set` without a corresponding getter, or
  # vice-versa; there's an expectation that a property that can be assigned a
  # value via an assignment operator can also have the value retrieved via
  # simple property access, and vice-versa.
  accessor-pairs:
    - error
    - setWithoutGet: true
      getWithoutSet: true
  
  # Never invoke one of Array's map/reduce methods without returning a value in
  # the callback; such methods rely on the return value to fulfill their
  # purpose. If the method was just being used to invoke a function for each
  # entry in an array, then use `Array.prototype.forEach` instead.
  array-callback-return: error

  # Never use a variable defined via `var` outside of the block in which it was
  # defined; it creates unexpected behavior due to variable hoisting. Instead,
  # move the definition to the top of the variable scope. Or better yet, use
  # `let` or `const` instead; they're both block-scoped.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  block-scoped-var: error

  # Never define a class method that doesn't reference `this`; it defies the
  # purpose of a class method, which is to operate on a specific instance of a
  # class. Instead, use a static class function.
  class-methods-use-this: error

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  complexity: off

  # Never define a function that returns a value in one code path but not
  # another; it creates doubt about whether or not it's intentional. Instead,
  # maintain consistency across all code paths. If one code path needs to return
  # a value, but another doesn't, then express intent by having the latter
  # return `null`; there's too much ambiguity involved with `undefined`.
  consistent-return:
    - error
    - treatUndefinedAsUnspecified: false

  # Put braces around conditional execution blocks unless every execution block
  # in a grouping fits on the same line as its condition; it makes the code a
  # little easier to read.
  curly:
    - error
    - multi-line
    - consistent

  # Always add a `// no default` comment at the bottom of `switch` blocks that
  # don't have a `default` case; it removes doubt about whether or not the lack
  # of a `default` case is intentional. It's common to forget to add a `default`
  # case.
  default-case: error

  # Always place the dot at the beginning of the property (instead of at the end
  # of the object) in multiline member expressions; it improves readability by
  # avoiding confusion caused by the role of periods in the English language to
  # indicate the end of a sentence.
  dot-location:
    - error
    - property

  # Use dot notation when accessing object properties unless bracket notation is
  # necessary, such as when the key is a `Symbol` or variable; it improves
  # readability. The `allowKeywords` option is set to `true` because maintaining
  # ES3 compatibility usually isn't a requirement. If it's a requirement, then
  # set `allowKeywords` to `false` in the local config file.
  dot-notation:
    - error
    - allowKeywords: true

  # Always use `===` instead of `==`; it removes the risk of making a mistake
  # due to an unexpected coercion or language quirk, and removes doubt about
  # whether or not the given equality operator is intentional; it's a common
  # accident to type `==` instead of `===`.
  eqeqeq:
    - error
    - always
    - null: always

  # Use `Object.prototype.hasOwnProperty` to filter out inherited properties
  # when looping through keys via `for`/`in` unless inherited properties are
  # necessary, in which case express intent by disabling this rule via an
  # inline comment. Otherwise, there's doubt about whether or not including
  # inherited properties is intentional; it's common to forget that `for`/`in`
  # includes both own and inherited properties.
  guard-for-in: error

  # Never use `alert`, `prompt`, or `confirm`; they create a poor user
  # experience. Instead, use a custom UI widget.
  no-alert: error

  # Never use `arguments.caller` or `arguments.callee`; they're deprecated.
  # Instead of using `arguments.caller`, the called function should accept the
  # calling function as a parameter. Instead of using `arguments.callee`, the
  # function should just reference itself by name.
  no-caller: error

  # Always put braces around a `case`'s execution block when it contains a
  # lexical declaration. Otherwise, it can lead to unexpected behavior because
  # the variable will be scoped to the entire `switch` block instead of only the
  # `case`'s execution block.
  no-case-declarations: error

  # Don't bother escaping an equal sign at the start of a regex literal; the
  # rest of the line provides sufficient context to avoid ambiguity with a
  # division operator.
  #
  # This rule is disabled because it's not a problem. 
  no-div-regex: off

  # Don't define an `else` block if the `if` block always returns when executed;
  # it reduces readability without adding value. Instead, put the code outside,
  # directly after the end of the `if` block.
  no-else-return: error

  # Don't define an empty function unless necessary, in which case express
  # intent by adding a comment inside of the function body. Otherwise, there's
  # doubt about whether or not it's intentional; it's a common accident to be
  # left with an empty function after refactoring.
  #
  # It'd be nice if there was an option in ESLint to allow a function named
  # "noop" to be empty without needing a comment, since the name expresses
  # intent.
  no-empty-function: error

  # Never define an empty pattern (e.g., `let {a: {}} = obj`) when
  # destructuring; no properties are ever assigned. It's a common accident to
  # type `:` instead of `=` when setting the default value of a property to an
  # empty object (e.g., `let {a = {}} = obj`).
  no-empty-pattern: error

  # Always use `===` when comparing a value against `null`. Using `==` instead
  # often leads to unexpected behavior because `true` will be returned if the
  # value is either `null` or `undefined`. If testing for both `null` or
  # `undefined`, then express intent by performing two separate comparisons
  # using `===`. Otherwise, there's doubt about whether or not it's intentional;
  # it's a common accident to type `==` instead of `===`.
  #
  # Note that the `eqeqeq` rule enforces the use of `===` over `==`. This rule
  # is only enabled in case the `eqeqeq` rule is disabled.
  no-eq-null: error

  # Don't use `eval` unless necessary, in which case disable this rule via an
  # inline comment. Using `eval` impacts performance, and opens the door for
  # code injection attacks.
  no-eval:
    - error
    - allowIndirect: false

  # Never modify native objects such as `Object`; there's an expectation about
  # how they behave. 
  no-extend-native: error

  # Never create a new function with `bind` if the new function doesn't use
  # `this` or perform argument binding, or if the target function is an arrow
  # function; it adds complexity without value.
  no-extra-bind: error

  # Never use a label if identical functionality can be achieved without one; it
  # adds complexity without value. It's a common accident to be left with an
  # unused label after refactoring.
  #
  # Note that the `no-labels` rule disallows labels. This rule is only enabled
  # in case the `no-labels` rule is disabled.
  no-extra-label: error

  # Never use fall-through logic in a `switch` block unless necessary, in which
  # case express intent by adding a `// fall through` comment at the end of the
  # `case` block. Otherwise, there's doubt about whether or not it's
  # intentional; it's common to forget to add a `break` statement at the end of
  # a `case` block.
  no-fallthrough: error

  # Never leave either side of the decimal point blank in a decimal number; it
  # reduces readability without adding value. Instead, add a zero (e.g., `0.3`
  # instead of `.3`, and `3.0` instead of `3.`).
  no-floating-decimal: error

  # Never reassign built-in global variables; there's an expectation about how
  # they behave.
  no-global-assign: error

  # Always perform coercions explicitly (e.g., `Boolean(val)`) instead of
  # implicitly (e.g., `!!val`); it's more expressive, and it removes doubt about
  # whether or not it's intentional; it's a common accident to type `!!` instead
  # of `!`.
  no-implicit-coercion:
    - error
    - boolean: true
      number: true
      string: true

  # Never implicitly declare a variable or function declaration in the global
  # scope; it creates doubt about whether or not it's intentional. It's common
  # to forget that top-level variable and function declarations are added as
  # properties to the global object. If done on purpose, then express intent by
  # explicitly assigning it to the global object (e.g., `window` in the browser,
  # or `global` in Node.js).
  no-implicit-globals: error

  # Don't indirectly invoke `eval`-like behavior, such as by passing code as the
  # first argument to `setTimeout`, unless necessary, in which case disable this
  # rule via an inline comment. Invoking `eval`-like behavior impacts
  # performance, and opens the door for code injection attacks.
  no-implied-eval: error

  # Don't use `this` outside of expected blocks, such as constructors and object
  # methods, unless necessary, in which case disable this rule via an inline
  # comment. In general, `this` is one of the most misunderstood and error-prone
  # features of JavaScript. It suffers from a tremendous lack of expressiveness.
  # A `this`-less style of programming should be embraced whenever possible.
  no-invalid-this: error

  # Always use ES6 iterators and generators instead of the __iterator__
  # property; it's deprecated.
  no-iterator: error

  # Don't use labels unless necessary, in which case disable this rule via an
  # inline comment. Labels add complexity because they work contrary to the
  # natural flow of the language. The cost of labels is usually higher than
  # their benefit.
  no-labels:
    - error
    - allowLoop: false
      allowSwitch: false

  # Don't create standalone code blocks unless necessary, in which case express
  # intent by disabling this rule via an inline comment. Otherwise, there's
  # doubt about whether or not it's intentional; it's a common accident to be
  # left with standalone code blocks after refactoring. There's rarely a
  # compelling reason to create a standalone code block on purpose.
  no-lone-blocks: error

  # Don't declare functions inside of loops unless necessary, in which case
  # disable this rule via an inline comment. Declaring a function inside of
  # a loop is highly error-prone, especially when the function makes use of
  # outer incremental variables declared via `var` since all instances of the
  # function will reference the same variable.
  no-loop-func: error

  # Assign numbers to descriptively named constants or properties (instead of
  # using them directly) unless accessing an array element, in which case
  # there's no need for additional expressiveness. Using numbers directly 
  # reduces readability because it's not always obvious what the number
  # represents. If this rule proves too onerous, then disable it in the local
  # config file.
  no-magic-numbers:
    - error
    - detectObjects: false
      enforceConst: true
      ignoreArrayIndexes: true

  # Don't chain multiple spaces together for purposes other than indentation;
  # it often creates doubt about whether or not it's intentional, or, in the
  # case of aligning object property values across multiple lines, makes the
  # code more difficult to maintain because whenever a new property is added to
  # the object with a longer name than the existing properties, all properties
  # in the object must be realigned, resulting in noisy diffs. It's a common
  # accident to type `  ` instead of ` `.
  #
  # Note that the `key-spacing` rule prevents multiple spaces from being added
  # after the colon in object property values.
  no-multi-spaces:
    - error
    - exceptions:
        Property: false

  # Always create multiline strings by using string concatenation or template
  # literals (instead of by putting `\` at the end of each line); it improves
  # readability.
  no-multi-str: error

  # Don't create functions using `new Function()` unless necessary, in which
  # case disable this rule via an inline comment. Creating functions in this way
  # impacts performance, and opens the door for code injection attacks.
  no-new-func: error

  # Never create primitives via `new String`, `new Number`, or `new Boolean`; it
  # leads to unexpected behavior because they're considered objects, causing
  # `typeof` to return "object", and `new Boolean(false)` to resolve to `true`.
  no-new-wrappers: error

  # Always assign the result of a constructor call to a variable when using
  # `new` unless it's not necessary, in which case express intent by disabling
  # this rule via an inline comment. Otherwise, there's doubt about whether or
  # not it's intentional; it's common to forget to assign the result to a
  # variable.
  no-new: error

  # Always use unicode escape sequences (instead of octal escape sequences) in
  # string literals; octal escape sequences are deprecated in ES5.
  no-octal-escape: error

  # Never use octal literals (e.g., `071`); they're deprecated in ES5.
  no-octal: error

  # Never reassign an argument; there's an expectation that an argument always
  # references the variable that was passed in when the function was invoked.
  # Instead, assign the argument to a local variable that can later be
  # reassigned as necessary.
  #
  # The `props` option is set to its default value of `false` because although
  # there's value in treating all arguments as immutable, doing so adds
  # significant overhead in terms of both performance and extra steps that must
  # be performed, particularly when it comes to deep cloning objects when
  # needing to return a modified copy. If embracing a purely functional
  # programming style, then set the `props` option to `true` in the local config
  # file.
  no-param-reassign:
    - error
    - props: false

  # Always use `Object.getPrototypeOf` instead of the `__proto__` property; the
  # `__proto__` property is deprecated in ES3.1.
  no-proto: error

  # Never redeclare a variable using `var`; it's pointless. Instead, use `let`
  # and just reassign the previously declared variable. It's common to forget
  # that the variable was previously declared.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  no-redeclare:
    - error
    - builtinGlobals: true

  # This rule is disabled. It may be enabled in the future if there are
  # properties that are deemed important enough to disallow by default.
  no-restricted-properties: off

  # Don't return an assignment expression unless necessary, in which case 
  # express intent by disabling this rule via an inline comment. Otherwise,
  # there's doubt about whether or not it's intentional; it's a common accident
  # to type `=` instead of `===` in a return statement. The `always` option is
  # used instead of the `except-parens` option because adding parentheses
  # doesn't sufficiently express intent.
  no-return-assign:
    - error
    - always

  # Never use `location.href = "javascript:<code>"`; it impacts performance, and
  # opens the door to the risk of injection attacks. Plus it's weird.
  no-script-url: error

  # Never assign a variable or object property to itself; it's pointless. It's
  # common for this to be done on accident.
  no-self-assign:
    - error
    - props: true

  # Never compare a variable to itself; it creates doubt about whether or not
  # it's intentional. It's common for this to be done on accident. If testing
  # for `NaN`, then use the global `isNaN` or `Number.isNaN` functions instead.
  no-self-compare: error

  # Never use the comma operator unless defining the initialization or
  # final-expression portions of a `for` statement; it adds complexity without
  # value.
  #
  # This rule only applies to the comma operator, which is used to include
  # multiple expressions where only one is expected, executing each expression
  # from left to right and returning the value of the last operand. It doesn't
  # apply to using commas in argument lists.
  no-sequences: error

  # Never throw any value other than an `Error` object, or an object that
  # extends `Error`; there's an expectation that a thrown error is an actual
  # `Error` with a stack trace.
  no-throw-literal: error

  # Don't create a loop with a condition that's not modified within the loop
  # unless necessary, in which case express intent by disabling this rule via an
  # inline comment; it's a common accident to create an infinite loop.
  no-unmodified-loop-condition: error

  # Never write an expression that doesn't have any effect; it's pointless. It's
  # common to make a mistake in logic that results in such an expression.
  no-unused-expressions:
    - error
    - allowShortCircuit: false
      allowTernary: false

  # Never define a label that's never used; it's pointless. It's a common
  # accident to be left with an unused label after refactoring.
  #
  # Note that the `no-labels` rule disallows labels. This rule is enabled just
  # in case the `no-labels` rule is disabled.
  no-unused-labels: error

  # Only use `.call` or `.apply` when necessary, such as when explicitly setting
  # `this`, or, in the case of `.apply`, when passing in arguments as an array.
  # Otherwise, it adds complexity without value. It's a common accident to be
  # left with an unnecessary `.call` or `.apply` after refactoring.
  #
  # Note that the `prefer-spread` rule enforces the use of the spread operator
  # over using `.apply`.
  no-useless-call: error

  # Only use string concatenation when necessary, such as when breaking up a
  # long string across multiple lines. It's a common accident to be left with
  # unnecessary string concatenation after refactoring.
  # 
  # Note that the `prefer-template` rule enforces the use of template literals
  # over string concatenation when embedding expressions. This rule addresses
  # situations that don't involve embedding expressions.
  no-useless-concat: error

  # Never escape non-special characters in strings, template literals, and
  # regular expressions; it's pointless. It's a common accident to escape the
  # wrong character.
  no-useless-escape: error

  # Never use the `void` operator; it's not expressive, and it adds complexity.
  # Instead, use `undefined`.
  #
  # Starting with ES5, the global `undefined` can't be redefined, and the
  # `no-shadow-restricted-names` rule already disallows shadowing `undefined`.
  no-void: error

  # Feel free to add inline reminders using `// TODO:` comments; it's more
  # effective than maintaining a list of issues in a separate document.
  #
  # This rule is set to `warn` so that it provides reminders about outstanding
  # issues but doesn't cause the build to fail.
  no-warning-comments: warn

  # Never use the `with` statement; it's disallowed in strict mode.
  no-with: error

  # Always provide the radix when using `parseInt`; it removes the risk of
  # making a mistake, and removes any doubt about whether or not the default
  # radix is intentional.
  #
  # This rule is still worth it even though in ES5 the `parseInt` function no
  # longer auto-detects octals, so the risk of accidentally ending up with the
  # wrong radix via auto-detection due to an errant leading zero is reduced.
  radix:
    - error
    - always

  # Always put `var` declarations at the top of the function or program; it
  # removes the risk of unexpected behavior due to variable hoisting.
  #
  # Note that the `no-var` rule enforces the use of `let` and `const` over
  # `var`. This rule is only enabled in case the `no-var` rule is disabled.
  vars-on-top: error

  # Always wrap immediately-invoked function expressions (even when invoked via
  # `.call` or `.apply`) in parentheses; it improves readability.
  #
  # The `inside` option is a purely stylistic preference, and is set merely to
  # maintain consistency.
  wrap-iife:
    - error
    - inside
    - functionPrototypeMethods: true

  # Never use the yoda style in conditionals; although typing `if (5 === x)`
  # instead of `if (x === 5)` does offer a little bit of protection against
  # accidental assignment, it comes at too high of a cost in terms of reduced
  # readability. The yoda style acts contrary to the natural flow of language
  # and thought. Also, the `no-cond-assign` rule already protects against the
  # accidental assignment of variables in conditionals, further reducing the
  # benefit of the yoda style.
  yoda:
    - error
    - never

  ###############
  # Strict Mode #
  ###############

  # Always enable strict mode at the global level; it prevents common mistakes.
  # In Node.js code, put `"use strict";` at the top of each module file. Once
  # ES6 modules are implemented, or when transpiling via babel, disable this
  # rule in the local config file, as strict mode is either implied or enabled
  # automatically.
  strict:
    - error
    - global

  #############
  # Variables #
  #############

  # Always assign variables at the same time that they're declared; it reduces
  # the risk of unexpected behavior due to the ambiguity of `undefined`, and it
  # removes any doubt about whether or not it's intentional. It's common to
  # forget to assign an initial value when declaring a variable. If declaring a
  # variable before its value has been determined, then assign it to `null`.
  #
  # Note that `undefined` can mean either "undeclared", "declared but
  # unassigned", or "declared and explicitly assigned to `undefined`". This
  # ambiguity is a major source of mistakes and confusion in JavaScript. This
  # rule plays a critical part in eliminating the ambiguity.
  init-declarations:
    - error
    - always

  # This rule is disabled because it protects against a bug that's only present
  # in IE8 and earlier.
  no-catch-shadow: off

  # Never use `delete` on a variable instead of an object's property; it doesn't
  # work. If resetting a variable, then reassign it to `null`.
  #
  # Note that the `prefer-reflect` rule enforces the use of
  # `Reflect.deleteProperty` over `delete`. This rule is only enabled in case
  # the `prefer-reflect` rule is disabled.
  no-delete-var: error

  # Never declare a variable with the same name as a label, or vice-versa; it
  # leads to unexpected behavior.
  #
  # Note that the `no-labels` rule disallows the use of labels. This rule is
  # only enabled in case the `no-labels` rule is disabled.
  no-label-var: error

  # This rule is disabled. It may be enabled in the future if there are global
  # variables that are deemed important enough to disallow by default.
  no-restricted-globals: off

  # Never shadow a global object or identifier such as `undefined`; there's an
  # expectation that global objects and identifiers can be referenced anywhere
  # by name.
  no-shadow-restricted-names: error

  # Never declare a variable in an inner scope with the same name as an existing
  # variable in an outer scope (including global variables); it leads to
  # unexpected behavior, and creates doubt about whether or not it's
  # intentional. It's common to forget that a variable with the same name was
  # already declared in the outer scope.
  #
  # The `hoist` option is set to `all` because although it's not technically
  # shadowing when the variable in the outer scope is declared after the inner
  # function, and thus the chance of closure-related mistakes is reduced, it
  # still makes the code harder to understand.
  no-shadow:
    - error
    - builtinGlobals: true
      hoist: all
 
  # Never initialize a variable to `undefined` unless necessary, in which case
  # disable this rule via an inline comment; there's too much ambiguity involved
  # with the use of `undefined`. Instead, use `null`.
  #
  # Note that the stated intention of this rule is to favor `var foo;` over
  # `var foo = undefined;` because `undefined` is implicit in the first form,
  # so it's deemed unnecessary to explicitly assign it. But that's not why this
  # rule is enabled here. Instead, this rule is enabled so as to promote the use
  # of `null` over `undefined` whenever possible. And if `undefined` really is
  # needed, then it should be assigned explicitly so as to express intent. The
  # `init-declarations` rule already prevents declaring a variable without
  # explicitly initializing it at the same time.
  no-undef-init: error

  # Never reference a variable that hasn't been declared, not even when using
  # the `typeof` operator; it creates doubt about whether or not it's
  # intentional. It's common to forget to declare a variable. If the variable is
  # a global that's not recognized by ESLint for the specified environment, then
  # add the variable to the `globals` section of the local config file.
  no-undef:
    - error
    - typeof: true

  # Always reference `undefined` directly instead of using `void`; it's more
  # expressive and less complex. Also, always compare object properties and
  # declared variables against `undefined` directly instead of using `typeof`;
  # it's less complex.
  # 
  # Note that the stated intention of this rule is to prevent unexpected
  # behavior from occurring as a result of the global `undefined` being
  # reassigned or shadowed. But starting with ES5, the global `undefined` can't
  # be redefined, and the `no-shadow-restricted-names` rule already disallows
  # shadowing `undefined`. Therefore, it's now safe to reference `undefined`
  # directly without having to resort to more complex and less expressive
  # alternatives. This rule is disabled as a result.
  #
  # However, this rule doesn't address favoring `null` over `undefined`. As
  # dictated by the `init-declarations` and `no-undef-init` rules, `undefined`
  # should only be used when necessary; it involves too much ambiguity. Instead,
  # use `null` whenever possible. But when `undefined` is the only option, then
  # reference it directly.
  no-undefined: off

  # Always use every variable and `catch`-block exception argument at least
  # once. Otherwise, it's pointless to declare them. Also, use every function
  # argument at least once unless writing a callback with a predefined argument
  # order when the first argument isn't needed but one or more subsequent ones
  # are, in which case express intent by disabling this rule via an inline
  # comment. Otherwise, there's doubt about whether or not it's intentional;
  # it's a common accident to be left with unused variables and arguments after
  # refactoring.
  no-unused-vars:
    - error
    - vars: all
      args: all
      caughtErrors: all

  # Never reference a variable, function, or class before defining it; it leads
  # to unexpected behavior due to hoisting, and, in the case of ES6 bindings
  # such as `let`, throws a `ReferenceError` when executed.
  no-use-before-define:
    - error
    - functions: true
      classes: true

  ########################
  # Node.js and CommonJS #
  ########################

  # Always return immediately after invoking a callback function unless it's
  # necessary not to, in which case express intent by disabling this rule via
  # an inline comment. Otherwise, there's doubt about whether or not it's
  # intentional; it's common to forget to return after invoking a callback
  # function.
  #
  # Note that this rule only applies to callback functions assigned to function
  # arguments named "callback", "cb", and "next".
  callback-return: error

  # Feel free to conditionally require modules. This rule is disabled because
  # it's not a problem.
  global-require: off

  # Always handle possible errors in functions that have an argument named
  # "err". Otherwise, errors go unhandled. It's common to forget to handle them.
  handle-callback-err: error

  # Never mix require statements with other variable declarations; it reduces
  # readability.
  no-mixed-requires:
    - error
    - grouping: false
      allowCall: true

  # Never use `new` in conjunction with a `require` statement; it creates
  # confusion and can lead to unexpected behavior. Instead, assign the result of
  # the `require` statement to a variable, and then use `new` in conjunction
  # with the variable.
  no-new-require: error

  # Never use string concatenation to create a directory or file path; it can
  # create incompatibilities across different platforms. Instead, use Node's
  # `path.join` or `path.resolve`.
  no-path-concat: error

  # Feel free to use `process.env`. This rule is disabled because it's not a
  # problem.
  no-process-env: off

  # Never use `process.exit`; there's an expectation that programs either run to
  # completion, or terminate with a non-zero error code due to a thrown error.
  no-process-exit: error

  # This rule is disabled. It may be enabled in the future if there are modules
  # that are deemed important enough to disallow by default.
  no-restricted-modules: off

  # Always use the asynchronous version of an I/O function unless absolutely
  # certain that the synchronous version won't impact performance, in which case
  # disable this rule via an inline comment. If it's always safe to use
  # synchronous I/O functions, then disable this rule in the local config file.
  no-sync: error

  ####################
  # Stylistic Issues #
  ####################

  # Never add spaces between array brackets and the tokens inside; it's harder
  # to type and it doesn't improve readability.
  array-bracket-spacing:
    - error
    - never

  # Always add a space between each brace and the code inside when writing a
  # single-line block; it helps distinguish the block from an object literal.
  #
  # Note that the `curly` rule allows braces to be omitted from the execution
  # blocks of single-line conditionals.
  block-spacing:
    - error
    - always

  # Always follow the one true brace style by putting the opening brace of a
  # block on the same line as its corresponding statement or declaration; it
  # improves readability.
  brace-style:
    - error
    - 1tbs
    - allowSingleLine: true

  # Always use camelcase instead of underscores when naming non-constants; it's
  # easier to type.
  camelcase:
    - error
    - properties: always

  # Always include a comma at the end of the last item in a multiline list; it
  # produces cleaner diffs when an item is added to or removed from the end.
  comma-dangle:
    - error
    - arrays: always-multiline
      exports: always-multiline
      functions: always-multiline
      imports: always-multiline
      objects: always-multiline

  # Always add a space after commas instead of before; it improves readability
  # due to consistency with the English language.
  comma-spacing:
    - error
    - after: true
      before: false

  # Always place commas after each item in a multiline list instead of before;
  # it produces cleaner diffs when an item is added to or removed from the
  # beginning, and it improves readability due to consistency with the English
  # language.
  comma-style:
    - error
    - last

  # Never add spaces between computed property brackets and the values inside;
  # it's harder to type and it doesn't improve readability.
  computed-property-spacing:
    - error
    - never

  # Always name a variable `self` when it's being used to capture `this`; it's
  # clearer than alternatives such as `that` or `me`.
  consistent-this:
    - error
    - self

  # Always add a trailing newline at the end of files; it makes it easier to
  # append files as well as output files to the terminal without messing up the
  # shell prompt.
  eol-last:
    - error
    - always

  # Never add a space between a function invocation and the opening parenthesis
  # of the argument list; it reduces readability by making function invocations
  # less distinguishable from function definitions.
  func-call-spacing:
    - error
    - never

  # Never give a function expression a different name than the variable or
  # object property to which it's assigned (except when assigning
  # `module.exports`); it reduces readability. Instead, give it the same name.
  # Or better yet, don't give it a name at all; in ES6, most functions are named
  # automatically.
  #
  # See the `func-names` rule for future changes that might impact this rule.
  func-name-matching:
    - error
    - includeCommonJSModuleExports: false

  # Always name function expressions when they're not automatically named;
  # otherwise, it reduces debuggability due to less explicit stack traces. Also,
  # never name function expressions when they're automatically named; repeating
  # or changing the name adds complexity without value.
  #
  # Note that this rule is disabled because it doesn't currently support the
  # desired policy. If https://github.com/eslint/eslint/pull/7244 is merged,
  # then this rule will be enabled with the `uninferred` option. Also note that
  # context-based automatic naming of functions is new to ES6.
  func-names: off

  # Only use a function expression or arrow function when necessary. Otherwise,
  # use a function declaration; they're less complex.
  #
  # Note that the `no-use-before-define` rule prevents function declarations
  # from being called before they're defined, thus removing any risk of
  # unexpected behavior due to hoisting. Also note that the
  # `no-restricted-syntax` rule disallows the use of arrow functions.
  func-style:
    - error
    - declaration
    - allowArrowFunctions: false

  # This rule is disabled. It may be enabled in the future if there are
  # identifiers that are deemed important enough to disallow by default.
  id-blacklist: off

  # Feel free to Uue identifiers of any length; even `i` is expressive enough in
  # many situations where iteration is obvious. This rule is disabled because
  # it's not a problem.
  id-length: off

  # This rule is disabled; it doesn't add enough value over other rules such as
  # `camelcase`.
  id-match: off

  # Always use two-space indentation; tabs often lead to funky alignment issues
  # across development environments, and indentations of more than two spaces
  # takes up too much room. Also, always indent each nested block only a single
  # level; indenting multiple levels each time takes up too much room.
  indent:
    - error
    - 2
    - SwitchCase: 1
      VariableDeclarator: 1
      outerIIFEBody: 1
      MemberExpression: 1
      FunctionDeclaration:
        parameters: 1
        body: 1
      FunctionExpression:
        parameters: 1
        body: 1

  # This rule is disabled due to lack of jsx usage. It may be enabled in the
  # future.
  jsx-quotes: off

  # Never add any spaces before the colon, and always add exactly one space
  # after the colon, when working with object literal properties; it improves
  # readability. 
  #
  # Note that the `no-multi-spaces` rule also prevents multiple spaces from
  # being added after the colon; although aligning property values across
  # multiple lines is cute, it's more difficult to maintain because whenever a
  # new property is added to the object with a longer name than the existing
  # properties, all properties in the object must be realigned, resulting in
  # noisy diffs.
  key-spacing:
    - error
    - afterColon: true
      beforeColon: false
      mode: strict

  # Always add a single space before and after keywords such as `if` and `else`;
  # it improves readability.
  keyword-spacing:
    - error
    - after: true
      before: true

  # Feel free to add line comments either above or on the same line as code.
  # This rule is disabled because it's not a problem.
  line-comment-position: off

  # Always use Unix line endings; Unix is a more common development environment
  # for Node.js than Windows.
  linebreak-style:
    - error
    - unix

  # Feel free to add comments wherever it seems useful. This rule is disabled
  # because it's not a problem.
  lines-around-comment: off

  # Always add empty lines before and after directives such as `"use strict";`;
  # it improves readability.
  lines-around-directive:
    - error
    - always

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-depth: off

  # Always limit lines to 80 characters; it's a long-established standard, and
  # code becomes less readable as the lines become longer.
  max-len:
    - error
    - code: 80
      tabWidth: 2
      comments: 80
      ignoreComments: false
      ignoreTrailingComments: false
      ignoreUrls: false
      ignoreStrings: false
      ignoreTemplateLiterals: false

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-lines: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-nested-callbacks: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-params: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-statements: off

  # This rule is disabled because it's too subjective and doesn't offer enough
  # value to be of use.
  max-statements-per-line: off

  # Never split a ternary operator across multiple lines; it adds more
  # complexity than value. Instead, use an expressive alternative, such as a
  # nested `if`/`else` statement.
  #
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  multiline-ternary:
    - error
    - never

  # Only use `new` in conjunction with functions that begin with an uppercase,
  # and only invoke functions that begin with an uppercase by using `new`.
  # Otherwise, it creates doubt about whether or not it's intentional because
  # there's an expectation that functions that start with uppercase are
  # constructors, and functions that start with lowercase aren't constructors.
  # If using a 3rd-party library that violates this expectation, then use the
  # `newIsCapExceptions` or `capIsNewExceptions` option to add an exception to
  # this rule in the local config file.
  new-cap:
    - error
    - capIsNew: true
      newIsCap: true
      properties: true

  # Always add parentheses to the end of the constructor when invoking it with
  # `new`, even if not providing any arguments. Otherwise, it creates doubt
  # about whether or not it's intentional; it's common to forget to specify
  # arguments when creating a new object.
  new-parens: error

  # Feel free to add or not add empty lines after variable declarations.
  # Sometimes it makes sense for multiple declarations to be grouped together,
  # and sometimes it doesn't. This rule is disabled because a universal rule is
  # too restrictive.
  newline-after-var: off

  # Feel free to add or not add an empty line before `return` statements. This
  # rule is disabled because it's not a problem.
  newline-before-return: off

  # Feel free to include multiple method calls on the same line or break it up
  # across multiple lines. This rule is disabled because it's not a problem.
  newline-per-chained-call: off

  # Never use the `Array` constructor unless necessary, in which case disable
  # this rule via an inline comment. Instead, use array literal notation
  # whenever possible.
  no-array-constructor: error

  # Never use bitwise operators such as `&` and `|` unless necessary, in which
  # case express intent by disabling this rule via an inline comment. Otherwise,
  # there's doubt about whether or not it's intentional; it's a common accident
  # to type `&` instead of `&&`.
  no-bitwise:
    - error
    - int32Hint: false

  # Feel free to use the `continue` statement. This rule is disabled because
  # it's not a problem.
  no-continue: off

  # Feel free to add comments wherever it makes sense to do so. This rule is
  # disabled because it's not a problem.
  no-inline-comments: off

  # Always use `else if` instead of nesting a lone `if` inside of an `else`'s
  # execution block; it improves readability.
  no-lonely-if: error

  # Always add extra parentheses when combining binary expressions of varying
  # precedence; it makes the logic easier to understand, and it removes doubt
  # about whether or not the expressions were written with a correct
  # understanding of the order of operations.
  no-mixed-operators:
    - error
    - allowSamePrecedence: true

  # Never mix tabs and spaces; it leads to unexpected alignment issues across
  # development environments. Instead, use spaces.
  #
  # Note that the `no-tabs` rule disallows the use of tabs.
  no-mixed-spaces-and-tabs: error

  # Never put more than one empty line in a row; it doesn't add value, and it
  # creates doubt about whether or not it's intentional. It's a common accident
  # to add two empty lines instead of one.
  no-multiple-empty-lines:
    - error
    - max: 1

  # Never negate conditions when writing an `if`/`else` statement or a ternary
  # expression; it adds complexity without value. Instead, invert the condition.
  no-negated-condition: error

  # Never use a nested ternary expression; it adds more complexity than value.
  # Instead, use an expressive alternative, such as nested `if`/`else`
  # statements.
  #
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  no-nested-ternary: error

  # Never create an object using `new Object();`; it adds complexity without
  # value. Instead, use an object literal.
  no-new-object: error

  # Don't use unary operators such as `++` unless writing the final expression
  # in a `for` statement; they lead to unexpected behavior due to automatic
  # semicolon insertion. Instead, use `+=`.
  no-plusplus:
    - error
    - allowForLoopAfterthoughts: true

  # Never use arrow functions; they reduce readability and produce unclear stack
  # traces. Instead, use named function expressions.
  no-restricted-syntax:
    - error
    - ArrowFunctionExpression

  # Never use tabs; they lead to unexpected alignment issues across development
  # environments. Instead, use spaces.
  no-tabs: error

  # Never use ternary operators; they add more complexity than value.
  #
  # Note that disallowing ternary operators is a difficult decision. They have
  # clear benefit in terms of conciseness. However, the cost of using them is
  # too steep due to how highly expressiveness and clarity are valued.
  no-ternary: error

  # Never add extra spaces to the end of a line; it's pointless. It's a common
  # accident to be left with extra spaces after refactoring.
  no-trailing-spaces:
    - error
    - skipBlankLines: false

  # Feel free to use dangling underscores in identifiers. This rule is disabled
  # because it's not a problem.
  no-underscore-dangle: off

  # Never use ternaries in situations that have easier alternatives (e.g.,
  # `let foo = bar ? bar : 1;` is better expressed as `let foo = bar || 1;`);
  # it adds complexity without value.
  #
  # Note that the `no-ternary` rule disallows the ternary operator. This rule is
  # only enabled in case the `no-ternary` rule is disabled.
  no-unneeded-ternary:
    - error
    - defaultAssignment: false

  # Never add whitespace around the dot or before the bracket of object
  # properties (except when indenting on a new line); it reduces readability
  # without adding value.
  no-whitespace-before-property: error

  # Always be consistent when adding new lines after properties in an object
  # literal or destructuring assignment; it improves readability. If all
  # properties fit on the same line, then put them on the same line. Otherwise,
  # put each property on its own line.
  #
  # Note that the `object-property-newline` rule enforces a similar style.
  object-curly-newline:
    - error
    - multiline: true

  # Never add spaces between object literal and destructuring assignment braces,
  # and the tokens inside; it's harder to type, and it doesn't improve
  # readability.
  object-curly-spacing:
    - error 
    - never

  # Always be consistent when adding new lines after properties in an object
  # literal; it improves readability. If all properties fit on the same line,
  # then put them on the same line. Otherwise, put each property on its own
  # line.
  #
  # Note that the `object-curly-newline` rule enforces a similar style.
  object-property-newline:
    - error
    - allowMultiplePropertiesPerLine: true

  # Always use a separate declaration for each variable; it improves readability
  # as well as diffs when changes are made.
  one-var:
    - error
    - never

  # Always put each variable declaration on its own line; it improves
  # readability as well as diffs when changes are made.
  #
  # Note that the `one-var` rule enforces a separate declaration to be made for
  # each variable, whereas this rule only addresses multi-variable declarations.
  # Therefore, this rule is only enabled in case the `one-var` rule is disabled.
  one-var-declaration-per-line:
    - error
    - always

  # Always use shorthand operators such as `+=` for simple math operations; it
  # improves readability.
  operator-assignment:
    - error
    - always

  # Always place the operator at the end of the current line instead of the
  # start of the next line when breaking an expression across multiple lines;
  # it improves readability by signaling that the expression continues on the
  # next line.
  operator-linebreak:
    - error
    - after

  # Never add empty lines as padding inside of blocks; it takes up more space
  # without improving readability.
  padded-blocks:
    - error
    - never

  # Only put quotes around property names when required. Otherwise, it decreases
  # readability without adding value.
  quote-props:
    - error
    - as-needed

  # Always use double quotes unless embedding an expression, in which case use
  # a template literal; double quotes are consistent with JSON, and single
  # quotes look too similar to backticks.
  quotes:
    - error
    - double
    - allowTemplateLiterals: true
      avoidEscape: false

  # This rule is disabled due to lack of jsdoc usage. It may be enabled in the
  # future.
  require-jsdoc: off

  # Never add a space before semicolons; it reduces readability. Also, always
  # add a space after semicolons when they're not at the end of a line; it
  # improves readability.
  semi-spacing:
    - error
    - after: true
      before: false
 
  # Always add a semicolon at the end of each statement (except when the full
  # statement is inside braces on a single line); it improves readability in
  # much the same way that periods at the end of each sentence improves
  # readability in the English language. In rare situations, it also avoids
  # unexpected behavior due to automatic semicolon insertion.
  semi:
    - error
    - always
    - omitLastInOneLineBlock: true

  # Feel free to sort object properties in whichever order that makes sense.
  # This rule is disabled because it's not a problem.
  sort-keys: off

  # Feel free to sort variable declarations in whichever order that makes sense.
  # This rule is disabled because it's not a problem.
  sort-vars: off

  # Always add a space before blocks; it improves readability.
  space-before-blocks:
    - error
    - always

  # Always add a space before the opening parenthesis in a function definition;
  # it helps distinguish a function definition from a function call.
  space-before-function-paren:
    - error
    - anonymous: always
      asyncArrow: always
      named: always

  # Never add spaces between parentheses and the contents inside; it's harder to
  # type, and it doesn't improve readability.
  space-in-parens:
    - error
    - never

  # Always add spaces around operators such as `+`; it improves readability.
  space-infix-ops:
    - error
    - int32Hint: false

  # Always add spaces after unary word operators such as `new` and `delete`; it
  # improves readability. Never add unnecessary spaces around unary non-word
  # operators such as `++`; it reduces readability without adding value.
  space-unary-ops:
    - error
    - words: true
      nonwords: false

  # Always add a space after the opening `//` or `/*` in a comment, and before
  # the closing `*/` when it's on the same line; it improves readability.
  spaced-comment:
    - error
    - always
    - block:
        balanced: true

  # Never specify whether or not a code unit is big or little endian; it's not
  # relevant when using UTF-8 encoding.
  unicode-bom:
    - error
    - never

  # Never wrap regex literals in parentheses; it reduces readability without
  # adding value.
  #
  # This rule is disabled because it's not a problem.
  wrap-regex: off

  ################
  # ECMAScript 6 #
  ################

  # Never use braces in conjunction with an arrow function; it adds more
  # complexity than value. If braces aren't needed, then remove them. If braces
  # are needed, then use a named function expression instead.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-body-style:
    - error
    - never

  # Only add parentheses around an arrow function's arguments when there's more
  # than one. Otherwise, it reduces readability without adding value.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-parens:
    - error
    - as-needed
    - requireForBlockBody: false

  # Always add a space before and after the `=>` when defining an arrow
  # function; it improves readability.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  arrow-spacing:
    - error
    - after: true
      before: true

  # Always call `super()` from within the constructors of derived classes.
  # Otherwise, it throws an error upon execution.
  constructor-super: error

  # Always add a space after the star, not before, when defining a generator
  # function; it improves readability.
  generator-star-spacing:
    - error
    - after: true
      before: false

  # Never reassign a class; there's an expectation that a class can always be
  # created by name once defined.
  no-class-assign: error

  # Never define an arrow function in a place where it can be confused with a
  # `>=` comparison operator; it reduces readability and creates doubt about
  # whether or not it's intentional. Instead, use a regular function.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is only enabled in case the `no-restricted-syntax` rule
  # is disabled.
  no-confusing-arrow:
    - error
    - allowParens: false

  # Never reassign a variable defined via `const`; it'll throw an error upon
  # execution. Instead, define the variable via `let`. It's common to forget
  # that a variable was defined via `const` instead of `let`.
  no-const-assign: error

  # Never define a class that has multiple properties with the same name; the
  # last occurrence shadows the one(s) before it.
  no-dupe-class-members: error

  # Always use a single `import` statement per module unless exporting from an
  # imported module, in which case the export should occur in a separate
  # statement. Otherwise, it adds complexity without value.
  no-duplicate-imports:
    - error
    - includeExports: false

  # Never use `new` when creating a `Symbol`; it's designed to be called as a
  # function.
  no-new-symbol: error

  # This rule is disabled. It may be enabled in the future if there are modules
  # that are deemed important enough to disallow by default.
  no-restricted-imports: off

  # Never reference `this` before `super` in the constructor of a derived class;
  # it throws a `ReferenceError`.
  no-this-before-super: error

  # Never use a computed property when it could be expressed as a non-computed
  # property; it adds complexity without value.
  no-useless-computed-key: error

  # Never define a class constructor if the implicit default constructor is
  # identical; it adds complexity without value.
  no-useless-constructor: error

  # Never rename a reference without actually changing the name when
  # destructing, importing, or exporting; it adds complexity without value.
  no-useless-rename:
    - error
    - ignoreDestructuring: false
      ignoreExport: false
      ignoreImport: false

  # Never use `var` to declare a variable; it leads to unexpected behavior due
  # to hoisting and not being block scoped. Instead, use `let` or `const`.
  no-var: error

  # Always use object shorthand syntax when possible; it improves readability.
  object-shorthand:
    - error
    - always
    - avoidQuotes: false
      ignoreConstructors: false

  # Only use an arrow function to return a single-line expression, and only when
  # it won't noticeably impact stack trace debugging. In all other situations,
  # use a function expression; it improves readability and stack traces.
  #
  # Note that the `no-restricted-syntax` rule disallows the use of arrow
  # functions. This rule is disabled because arrow functions should be used
  # sparingly if the `no-restricted-syntax` rule is enabled. In most situations,
  # the cost of using them is greater than the benefit.
  prefer-arrow-callback: off

  # Always use `const` instead of `let` when the variable isn't reassigned; it's
  # more expressive and protects against accidental reassignment.
  prefer-const:
    - error
    - destructuring: any
      ignoreReadBeforeAssign: false

  # Never use `parseInt` with a radix value of `2`, `8`, or `16`. Instead, use
  # the binary, octal, and hexadecimal literals added in ES6; they're more
  # expressive.
  prefer-numeric-literals: error

  # Always prefer ES6 `Reflect` methods over their pre-ES6 alternatives; they
  # more closely represent the inner workings of JavaScript without sacrificing
  # readability.
  prefer-reflect: error

  # Always use rest parameters (e.g., `...`) instead of `arguments` when
  # converting a list of arguments into a single variable; unlike `arguments`,
  # it creates a proper array, and also adds flexibility in choosing which
  # arguments are converted.
  prefer-rest-params: error

  # Always use the spread operator (e.g., `...vals`) to convert an array into a
  # list of arguments when passing them to a function, instead of calling the
  # function via `.apply`; it's more expressive, and also adds flexibility in
  # choosing which arguments are converted.
  prefer-spread: error

  # Always use template literals instead of string concatenation when embedding
  # expressions into a string; it's more expressive, and it improves
  # readability.
  prefer-template: error

  # Never define a generator function that doesn't call `yield`; it's pointless.
  # Instead, use a regular function.
  require-yield: error

  # Never add a space between the spread operator and its expression; it reduces
  # readability without adding value.
  rest-spread-spacing:
    - error
    - never

  # Feel free to sort imports in whichever order that makes sense. This rule is
  # disabled because it's not a problem.
  sort-imports: error

  # Always provide a description when defining a `Symbol`; it improves
  # debugging.
  symbol-description: error

  # Never add spaces between template literal braces and the expression inside;
  # it's harder to type, and it doesn't improve readability.
  template-curly-spacing:
    - error
    - never

  # Always add a space after the star, not before, when using the `yield`
  # statement; it improves readability.
  yield-star-spacing:
    - error
    - after: true
      before: false
